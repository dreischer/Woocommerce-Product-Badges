{"version":3,"sources":["webpack:///back-end.js","webpack:///webpack/bootstrap 1f347d02cb19b7e701b5","webpack:///./back-end/js/index.jsx","webpack:///./node_modules/preact/dist/preact.esm.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","setData","data","console","log","document","getElementById","config","DATA_ELEMENT","value","JSON","stringify","__WEBPACK_IMPORTED_MODULE_0_preact__","CONTAINER_ELEMENT","parse","e","Table","Component","props","super","this","state","assign","sizes","rows","measure","values","__proto__","create","constructor","componentDidUpdate","addMeasure","const","concat","setState","deleteMeasure","slice","map","row","addSize","deleteSize","render","headings","size","h","unshift","className","onClick","bind","VNode","nodeName","attributes","lastSimple","child","simple","children","EMPTY_CHILDREN","arguments","length","stack","push","pop","undefined","String","key","options","vnode","extend","obj","cloneElement","enqueueRender","component","_dirty","items","debounceRendering","defer","rerender","list","renderComponent","isSameNodeType","node","hydrating","splitText","_componentConstructor","isNamedNode","normalizedNodeName","toLowerCase","getNodeProps","defaultProps","createNode","isSvg","createElementNS","createElement","removeNode","parentNode","removeChild","setAccessor","old","style","cssText","IS_NON_DIMENSIONAL","test","innerHTML","__html","useCapture","replace","substring","addEventListener","eventProxy","removeEventListener","_listeners","setProperty","removeAttribute","ns","removeAttributeNS","setAttributeNS","setAttribute","type","event","flushMounts","mounts","afterMount","componentDidMount","diff","dom","context","mountAll","parent","componentRoot","diffLevel","isSvgMode","ownerSVGElement","ret","idiff","appendChild","out","prevSvgMode","_component","nodeValue","createTextNode","replaceChild","recollectNodeTree","vnodeName","buildComponentFromVNode","firstChild","fc","vchildren","a","nextSibling","innerDiffNode","dangerouslySetInnerHTML","diffAttributes","isHydrating","j","f","vchild","originalChildren","childNodes","keyed","keyedLen","min","len","childrenLen","vlen","_child","__key","trim","insertBefore","unmountOnly","unmountComponent","ref","removeChildren","lastChild","next","previousSibling","attrs","collectComponent","components","createComponent","Ctor","inst","doRender","nextBase","splice","setComponentProps","opts","_disable","__ref","base","componentWillMount","componentWillReceiveProps","prevContext","prevProps","syncComponentUpdates","isChild","rendered","cbase","previousProps","previousState","prevState","previousContext","isUpdate","initialBase","initialChildComponent","skip","shouldComponentUpdate","componentWillUpdate","getChildContext","toUnmount","childComponent","childProps","_parentComponent","baseParent","componentRef","t","afterUpdate","_renderCallbacks","originalComponent","oldDom","isDirectOwner","isOwner","beforeUnmount","componentWillUnmount","inner","merge","Promise","resolve","then","setTimeout","callback","forceUpdate","preact"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAI,EAAAJ,EACAK,GAAA,EACAH,WAUA,OANAJ,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,GAAA,EAGAF,EAAAD,QAvBA,GAAAD,KA4BAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,SAAAP,EAAAQ,EAAAC,GACAZ,EAAAa,EAAAV,EAAAQ,IACAG,OAAAC,eAAAZ,EAAAQ,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAZ,EAAAmB,EAAA,SAAAf,GACA,GAAAQ,GAAAR,KAAAgB,WACA,WAA2B,MAAAhB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAJ,GAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAjB,KAAAc,EAAAC,IAGtDtB,EAAAyB,EAAA,GAGAzB,IAAA0B,EAAA,KDKO,CAED,SAAUtB,EAAQuB,EAAqB3B,GAE7C,YEmBA,SAAS4B,GAASC,GAChBC,QAAQC,IAAI,aAAcF,GAC1BG,SAASC,eAAeC,EAAOC,cAAcC,MAAQC,KAAKC,UAAUT,GFpBtEf,OAAOC,eAAeY,EAAqB,cAAgBS,OAAO,GAC7C,IAAIG,GAAuCvC,EAAoB,GEtE9EkC,GACJC,aAAc,mBACdK,kBAAmB,wBAGfX,EAuFN,WACE,IACE,MAAOQ,MAAKI,MAAMT,SAASC,eAAeC,EAAOC,cAAcC,OAC/D,MAAOM,GACP,aAzFEC,EAAuB,SAAAC,GAC3B,QAAAD,GAAaE,GACXC,EAAKvC,KAACwC,KAAAF,GACNE,KAAKC,MAAQlC,OAAOmC,QAClBC,OAAQ,IAAK,IAAK,KAClBC,OAEIC,QAAS,OACTC,QAAS,GAAI,GAAI,MAGjBD,QAAS,QACTC,QAAS,GAAI,GAAI,OAGpBN,KAAKF,OF2IV,MA/DKD,KAAYD,EAAMW,UAAYV,GACnCD,EAAMpB,UAAYT,OAAOyC,OAAQX,GAAaA,EAAUrB,WACxDoB,EAAMpB,UAAUiC,YAAcb,EE5E9BA,EAAApB,UAAAkC,mBAAmB,WACjB7B,EAAQmB,KAAKC,QAEfL,EAAApB,UAAAmC,WAAW,WACTC,GAAMR,GAAWJ,KAAKC,MAAMG,KAAIS,SAC9BR,QAAS,GACTC,YAGFN,MAAKc,UAAWV,UAElBR,EAAApB,UAAAuC,cAAc,WACZH,GAAMT,GAAQH,KAAKC,MAAME,MAAMa,MAAM,GAAI,GACnCZ,EAAOJ,KAAKC,MAAMG,KAAKa,IAAI,SAAAC,GAC/B,MAAOnD,QAAOmC,OAAOgB,GACnBZ,OAAQY,EAAIZ,OAAOU,MAAM,GAAI,MAIjChB,MAAKc,UAAWX,QAAOC,UAEzBR,EAAApB,UAAA2C,QAAQ,WACNP,GAAMT,GAAYH,KAAKC,MAAME,MAAKU,QAAE,KAC9BT,EAAOJ,KAAKC,MAAMG,KAAKa,IAAI,SAAAC,GAC/B,MAAOnD,QAAOmC,OAAOgB,GACnBZ,OAAYY,EAAIZ,OAAMO,QAAE,QAI5Bb,MAAKc,UAAWX,QAAOC,UAEzBR,EAAApB,UAAA4C,WAAW,aAGXxB,EAAApB,UAAA6C,OAAO,SAACvB,EAAOG,GACbW,GAAMU,GAAWrB,EAAME,MAAMc,IAAI,SAAAM,GAAQ,MAAA/B,GAAA,EAAAgC,EAAC,KAAE,KAAED,IAC9CD,GAASG,QAAQjC,EAAA,EAAAgC,EAAC,KAAE,MAEpBZ,IAAMR,GAAOH,EAAMG,KAAKa,IAAI,SAAAC,GAC1BN,GAAMN,GAASY,EAAIZ,OAAOW,IAAI,SAAAM,GAAQ,MAAA/B,GAAA,EAAAgC,EAAC,KAAE,KAAED,IAC3C,OACE/B,GAAA,EAAAgC,EAAC,KAAE,KACDhC,EAAA,EAAAgC,EAAC,KAAE,KAAEN,EAAIb,SACRC,IAKP,OACEd,GAAA,EAAAgC,EAAC,MAAG,KACFhC,EAAA,EAAAgC,EAAC,QAAK,KACJhC,EAAA,EAAAgC,EAAC,KAAE,KAAEF,GACJlB,GAEHZ,EAAA,EAAAgC,EAAC,OAAIE,UAAU,WAAWC,QAAS3B,KAAKmB,QAAQS,KAAK5B,OAAO,YAC5DR,EAAA,EAAAgC,EAAC,OAAIE,UAAU,cAAcC,QAAS3B,KAAKW,WAAWiB,KAAK5B,OAAO,iBFkFjEJ,GE1JWJ,EAAA,EA8EpBA,GAAA,EAAM6B,OAAO7B,EAAA,EAAAgC,EAAC5B,GAAMd,KAAMA,IAAUG,SAASC,eAAeC,EAAOM,qBFiG7D,SAAUpC,EAAQuB,EAAqB3B,GAE7C,YGzLA,SAAA4E,MAuCA,QAAAL,GAAAM,EAAAC,GACA,GACAC,GACAC,EACAC,EACA5E,EAJA6E,EAAAC,CAKA,KAAA9E,EAAA+E,UAAAC,OAA2BhF,KAAA,GAC3BiF,EAAAC,KAAAH,UAAA/E,GAMA,KAJAyE,GAAA,MAAAA,EAAAI,WACAI,EAAAD,QAAAC,EAAAC,KAAAT,EAAAI,gBACAJ,GAAAI,UAEAI,EAAAD,QACA,IAAAL,EAAAM,EAAAE,YAAAC,KAAAT,EAAAQ,IACA,IAAAnF,EAAA2E,EAAAK,OAAyBhF,KACzBiF,EAAAC,KAAAP,EAAA3E,QAGA,iBAAA2E,OAAA,OAEAC,EAAA,kBAAAJ,MACA,MAAAG,IAAA,GAAkC,gBAAAA,KAAAU,OAAAV,GAA0D,gBAAAA,KAAAC,GAAA,IAG5FA,GAAAF,EACAG,IAAAG,OAAA,IAAAL,EACIE,IAAAC,EACJD,GAAAF,GAEAE,EAAAK,KAAAP,GAGAD,EAAAE,CAIA,IAAAxD,GAAA,GAAAmD,EASA,OARAnD,GAAAoD,WACApD,EAAAyD,WACAzD,EAAAqD,WAAA,MAAAA,MAAAW,GAAAX,EACArD,EAAAkE,IAAA,MAAAb,MAAAW,GAAAX,EAAAa,QAGAF,KAAAG,EAAAC,OAAAD,EAAAC,MAAApE,GAEAA,EAOA,QAAAqE,GAAAC,EAAAlD,GACA,OAAAxC,KAAAwC,GACAkD,EAAA1F,GAAAwC,EAAAxC,EACG,OAAA0F,GAQH,QAAAC,GAAAH,EAAAhD,GACA,MAAA0B,GAAAsB,EAAAhB,SAAAiB,OAA0CD,EAAAf,YAAAjC,GAAAuC,UAAAC,OAAA,KAAAtB,MAAAxD,KAAA6E,UAAA,GAAAS,EAAAX,UAU1C,QAAAe,GAAAC,IACAA,EAAAC,SAAAD,EAAAC,QAAA,OAAAC,EAAAb,KAAAW,KACAN,EAAAS,mBAAAC,GAAAC,GAIA,QAAAA,KACA,GAAA9E,GACA+E,EAAAJ,CAEA,KADAA,KACA3E,EAAA+E,EAAAhB,OACA/D,EAAA0E,QAAAM,EAAAhF,GASA,QAAAiF,GAAAC,EAAAd,EAAAe,GACA,sBAAAf,IAAA,gBAAAA,OACAJ,KAAAkB,EAAAE,UAEA,gBAAAhB,GAAAhB,UACA8B,EAAAG,uBAAAC,EAAAJ,EAAAd,EAAAhB,UAEA+B,GAAAD,EAAAG,wBAAAjB,EAAAhB,SAOA,QAAAkC,GAAAJ,EAAA9B,GACA,MAAA8B,GAAAK,qBAAAnC,GAAA8B,EAAA9B,SAAAoC,gBAAApC,EAAAoC,cAUA,QAAAC,GAAArB,GACA,GAAAhD,GAAAiD,KAAsBD,EAAAf,WACtBjC,GAAAqC,SAAAW,EAAAX,QAEA,IAAAiC,GAAAtB,EAAAhB,SAAAsC,YACA,QAAA1B,KAAA0B,EACA,OAAA9G,KAAA8G,OACA1B,KAAA5C,EAAAxC,KACAwC,EAAAxC,GAAA8G,EAAA9G,GAKA,OAAAwC,GAQA,QAAAuE,GAAAvC,EAAAwC,GACA,GAAAV,GAAAU,EAAArF,SAAAsF,gBAAA,6BAAAzC,GAAA7C,SAAAuF,cAAA1C,EAEA,OADA8B,GAAAK,mBAAAnC,EACA8B,EAMA,QAAAa,GAAAb,GACA,GAAAc,GAAAd,EAAAc,UACAA,MAAAC,YAAAf,GAYA,QAAAgB,GAAAhB,EAAAhG,EAAAiH,EAAAxF,EAAAiF,GAGA,GAFA,cAAA1G,MAAA,SAEA,QAAAA,OAEE,YAAAA,EACFiH,KAAA,MACAxF,KAAAuE,OACE,cAAAhG,GAAA0G,EAEA,aAAA1G,GAIF,GAHAyB,GAAA,gBAAAA,IAAA,gBAAAwF,KACAjB,EAAAkB,MAAAC,QAAA1F,GAAA,IAEAA,GAAA,gBAAAA,GAAA,CACA,mBAAAwF,GACA,OAAAvH,KAAAuH,GACAvH,IAAA+B,KAAAuE,EAAAkB,MAAAxH,GAAA,GAGA,QAAAA,KAAA+B,GACAuE,EAAAkB,MAAAxH,GAAA,gBAAA+B,GAAA/B,KAAA,IAAA0H,EAAAC,KAAA3H,GAAA+B,EAAA/B,GAAA,KAAA+B,EAAA/B,QAGE,gCAAAM,EACFyB,IAAAuE,EAAAsB,UAAA7F,EAAA8F,QAAA,QACE,SAAAvH,EAAA,SAAAA,EAAA,IACF,GAAAwH,GAAAxH,SAAAyH,QAAA,eACAzH,KAAAsG,cAAAoB,UAAA,GACAjG,EACAwF,GAAAjB,EAAA2B,iBAAA3H,EAAA4H,EAAAJ,GAEAxB,EAAA6B,oBAAA7H,EAAA4H,EAAAJ,IAEAxB,EAAA8B,aAAA9B,EAAA8B,gBAA2C9H,GAAAyB,MACzC,aAAAzB,GAAA,SAAAA,IAAA0G,GAAA1G,IAAAgG,GACF+B,EAAA/B,EAAAhG,EAAA,MAAAyB,EAAA,GAAAA,GACA,MAAAA,IAAA,IAAAA,GAAAuE,EAAAgC,gBAAAhI,OACE,CACF,GAAAiI,GAAAvB,GAAA1G,SAAAyH,QAAA,gBACA,OAAAhG,IAAA,IAAAA,EACAwG,EAAAjC,EAAAkC,kBAAA,+BAAAlI,EAAAsG,eAAsFN,EAAAgC,gBAAAhI,GACnF,kBAAAyB,KACHwG,EAAAjC,EAAAmC,eAAA,+BAAAnI,EAAAsG,cAAA7E,GAA0FuE,EAAAoC,aAAApI,EAAAyB,QAlC1FuE,GAAAlC,UAAArC,GAAA,GA0CA,QAAAsG,GAAA/B,EAAAhG,EAAAyB,GACA,IACAuE,EAAAhG,GAAAyB,EACE,MAAAM,KAMF,QAAA6F,GAAA7F,GACA,MAAAK,MAAA0F,WAAA/F,EAAAsG,MAAApD,EAAAqD,OAAArD,EAAAqD,MAAAvG,OAgBA,QAAAwG,KAEA,IADA,GAAAzI,GACAA,EAAA0I,EAAA3D,OACAI,EAAAwD,YAAAxD,EAAAwD,WAAA3I,GACAA,EAAA4I,mBAAA5I,EAAA4I,oBAUA,QAAAC,GAAAC,EAAA1D,EAAA2D,EAAAC,EAAAC,EAAAC,GAEAC,MAEAC,EAAA,MAAAH,OAAAjE,KAAAiE,EAAAI,gBAGAlD,EAAA,MAAA2C,KAAA,iBAAAA,IAGA,IAAAQ,GAAAC,EAAAT,EAAA1D,EAAA2D,EAAAC,EAAAE,EAYA,OATAD,IAAAK,EAAAtC,aAAAiC,KAAAO,YAAAF,KAGAH,IACAhD,GAAA,EAEA+C,GAAAT,KAGAa,EAIA,QAAAC,GAAAT,EAAA1D,EAAA2D,EAAAC,EAAAE,GACA,GAAAO,GAAAX,EACAY,EAAAN,CAMA,IAHA,MAAAhE,GAAA,iBAAAA,OAAA,IAGA,gBAAAA,IAAA,gBAAAA,GAmBA,MAhBA0D,QAAA9D,KAAA8D,EAAA1C,WAAA0C,EAAA9B,cAAA8B,EAAAa,YAAAT,GAEAJ,EAAAc,WAAAxE,IACA0D,EAAAc,UAAAxE,IAIAqE,EAAAlI,SAAAsI,eAAAzE,GACA0D,IACAA,EAAA9B,YAAA8B,EAAA9B,WAAA8C,aAAAL,EAAAX,GACAiB,EAAAjB,GAAA,KAIAW,EAAA,iBAEAA,CAIA,IAAAO,GAAA5E,EAAAhB,QACA,sBAAA4F,GACA,MAAAC,GAAAnB,EAAA1D,EAAA2D,EAAAC,EAQA,IAJAI,EAAA,QAAAY,GAAA,kBAAAA,GAAAZ,EAGAY,EAAA/E,OAAA+E,KACAlB,IAAAxC,EAAAwC,EAAAkB,MACAP,EAAA9C,EAAAqD,EAAAZ,GAEAN,GAAA,CAEA,KAAAA,EAAAoB,YACAT,EAAAD,YAAAV,EAAAoB,WAEApB,GAAA9B,YAAA8B,EAAA9B,WAAA8C,aAAAL,EAAAX,GAGAiB,EAAAjB,GAAA,GAIA,GAAAqB,GAAAV,EAAAS,WACA9H,EAAAqH,EAAA,cACAW,EAAAhF,EAAAX,QAEA,UAAArC,EAAA,CACAA,EAAAqH,EAAA,gBACA,QAAAY,GAAAZ,EAAApF,WAAAzE,EAAAyK,EAAAzF,OAA4ChF,KAC5CwC,EAAAiI,EAAAzK,GAAAM,MAAAmK,EAAAzK,GAAA+B,MAqBA,OAhBAwE,GAAAiE,GAAA,IAAAA,EAAAxF,QAAA,gBAAAwF,GAAA,UAAAD,OAAAnF,KAAAmF,EAAA/D,WAAA,MAAA+D,EAAAG,YACAH,EAAAP,WAAAQ,EAAA,KACAD,EAAAP,UAAAQ,EAAA,KAIAA,KAAAxF,QAAA,MAAAuF,IACAI,EAAAd,EAAAW,EAAArB,EAAAC,EAAA7C,GAAA,MAAA/D,EAAAoI,yBAIAC,EAAAhB,EAAArE,EAAAf,WAAAjC,GAGAgH,EAAAM,EAEAD,EAUA,QAAAc,GAAAzB,EAAAsB,EAAArB,EAAAC,EAAA0B,GACA,GAQAC,GACA3K,EACA4K,EACAC,EACAtG,EAZAuG,EAAAhC,EAAAiC,WACAtG,KACAuG,KACAC,EAAA,EACAC,EAAA,EACAC,EAAAL,EAAAlG,OACAwG,EAAA,EACAC,EAAAjB,IAAAxF,OAAA,CAQA,QAAAuG,EACA,OAAAvL,GAAA,EAAiBA,EAAAuL,EAASvL,IAAA,CAC1B,GAAA0L,GAAAR,EAAAlL,GACAwC,EAAAkJ,EAAA,cACApG,EAAAmG,GAAAjJ,EAAAkJ,EAAA3B,WAAA2B,EAAA3B,WAAA4B,MAAAnJ,EAAA8C,IAAA,IACA,OAAAA,GACA+F,IACAD,EAAA9F,GAAAoG,IACIlJ,QAAA4C,KAAAsG,EAAAlF,WAAAsE,GAAAY,EAAA1B,UAAA4B,OAAAd,MACJjG,EAAA2G,KAAAE,GAKA,OAAAD,EACA,OAAAzL,GAAA,EAAiBA,EAAAyL,EAAUzL,IAAA,CAC3BiL,EAAAT,EAAAxK,GACA2E,EAAA,IAGA,IAAAW,GAAA2F,EAAA3F,GACA,UAAAA,EACA+F,OAAAjG,KAAAgG,EAAA9F,KACAX,EAAAyG,EAAA9F,GACA8F,EAAA9F,OAAAF,GACAiG,SAIA,KAAA1G,GAAA2G,EAAAE,EACA,IAAAT,EAAAO,EAAkBP,EAAAS,EAAiBT,IACnC,OAAA3F,KAAAP,EAAAkG,IAAA1E,EAAAjG,EAAAyE,EAAAkG,GAAAE,EAAAH,GAAA,CACAnG,EAAAvE,EACAyE,EAAAkG,OAAA3F,GACA2F,IAAAS,EAAA,GAAAA,IACAT,IAAAO,MACA,OAMA3G,EAAAgF,EAAAhF,EAAAsG,EAAA9B,EAAAC,GAEA4B,EAAAE,EAAAlL,GACA2E,OAAAuE,GAAAvE,IAAAqG,IACA,MAAAA,EACA9B,EAAAU,YAAAjF,GACKA,IAAAqG,EAAAN,YACLvD,EAAA6D,GAEA9B,EAAA2C,aAAAlH,EAAAqG,IAOA,GAAAK,EACA,OAAArL,KAAAoL,OACAhG,KAAAgG,EAAApL,IAAAmK,EAAAiB,EAAApL,IAAA,EAKA,MAAAsL,GAAAE,OACApG,MAAAT,EAAAE,EAAA2G,OAAArB,EAAAxF,GAAA,GAQA,QAAAwF,GAAA7D,EAAAwF,GACA,GAAAjG,GAAAS,EAAAyD,UACAlE,GAEAkG,EAAAlG,IAIA,MAAAS,EAAA,eAAAA,EAAA,cAAA0F,KAAA1F,EAAA,cAAA0F,IAAA,OAEA,IAAAF,GAAA,MAAAxF,EAAA,eACAa,EAAAb,GAGA2F,EAAA3F,IAQA,QAAA2F,GAAA3F,GAEA,IADAA,IAAA4F,UACA5F,GAAA,CACA,GAAA6F,GAAA7F,EAAA8F,eACAjC,GAAA7D,GAAA,GACAA,EAAA6F,GASA,QAAAtB,GAAA3B,EAAAmD,EAAA9E,GACA,GAAAjH,EAGA,KAAAA,IAAAiH,GACA8E,GAAA,MAAAA,EAAA/L,IAAA,MAAAiH,EAAAjH,IACAgH,EAAA4B,EAAA5I,EAAAiH,EAAAjH,GAAAiH,EAAAjH,OAAA8E,GAAAoE,EAKA,KAAAlJ,IAAA+L,GACA,aAAA/L,GAAA,cAAAA,OAAAiH,IAAA8E,EAAA/L,MAAA,UAAAA,GAAA,YAAAA,EAAA4I,EAAA5I,GAAAiH,EAAAjH,KACAgH,EAAA4B,EAAA5I,EAAAiH,EAAAjH,GAAAiH,EAAAjH,GAAA+L,EAAA/L,GAAAkJ,GAYA,QAAA8C,GAAAzG,GACA,GAAAvF,GAAAuF,EAAA1C,YAAA7C,MACAiM,EAAAjM,KAAAiM,EAAAjM,QAAA4E,KAAAW,GAIA,QAAA2G,GAAAC,EAAAjK,EAAA2G,GACA,GACAuD,GADAvG,EAAAoG,EAAAE,EAAAnM,KAYA,IATAmM,EAAAvL,WAAAuL,EAAAvL,UAAA6C,QACA2I,EAAA,GAAAD,GAAAjK,EAAA2G,GACA5G,EAAArC,KAAAwM,EAAAlK,EAAA2G,KAEAuD,EAAA,GAAAnK,GAAAC,EAAA2G,GACAuD,EAAAvJ,YAAAsJ,EACAC,EAAA3I,OAAA4I,GAGAxG,EACA,OAAAnG,GAAAmG,EAAAnB,OAA2BhF,KAC3B,GAAAmG,EAAAnG,GAAAmD,cAAAsJ,EAAA,CACAC,EAAAE,SAAAzG,EAAAnG,GAAA4M,SACAzG,EAAA0G,OAAA7M,EAAA,EACA,OAIA,MAAA0M,GAIA,QAAAC,GAAAnK,EAAAG,EAAAwG,GACA,MAAAzG,MAAAS,YAAAX,EAAA2G,GASA,QAAA2D,GAAAjH,EAAArD,EAAAuK,EAAA5D,EAAAC,GACAvD,EAAAmH,WACAnH,EAAAmH,UAAA,GAEAnH,EAAAoH,MAAAzK,EAAAwJ,YAAAxJ,GAAAwJ,KACAnG,EAAA8F,MAAAnJ,EAAA8C,YAAA9C,GAAA8C,KAEAO,EAAAqH,MAAA9D,EACAvD,EAAAsH,oBAAAtH,EAAAsH,qBACEtH,EAAAuH,2BACFvH,EAAAuH,0BAAA5K,EAAA2G,GAGAA,OAAAtD,EAAAsD,UACAtD,EAAAwH,cAAAxH,EAAAwH,YAAAxH,EAAAsD,SACAtD,EAAAsD,WAGAtD,EAAAyH,YAAAzH,EAAAyH,UAAAzH,EAAArD,OACAqD,EAAArD,QAEAqD,EAAAmH,UAAA,EAEA,IAAAD,IACA,IAAAA,IAAA,IAAAxH,EAAAgI,sBAAA1H,EAAAqH,KAGAtH,EAAAC,GAFAO,EAAAP,EAAA,EAAAuD,IAMAvD,EAAAoH,OAAApH,EAAAoH,MAAApH,IASA,QAAAO,GAAAP,EAAAkH,EAAA3D,EAAAoE,GACA,IAAA3H,EAAAmH,SAAA,CAEA,GAWAS,GACAf,EACAgB,EAbAlL,EAAAqD,EAAArD,MACAG,EAAAkD,EAAAlD,MACAwG,EAAAtD,EAAAsD,QACAwE,EAAA9H,EAAAyH,WAAA9K,EACAoL,EAAA/H,EAAAgI,WAAAlL,EACAmL,EAAAjI,EAAAwH,aAAAlE,EACA4E,EAAAlI,EAAAqH,KACAN,EAAA/G,EAAA+G,SACAoB,EAAAD,GAAAnB,EACAqB,EAAApI,EAAAkE,WACAmE,GAAA,CAuBA,IAjBAH,IACAlI,EAAArD,MAAAmL,EACA9H,EAAAlD,MAAAiL,EACA/H,EAAAsD,QAAA2E,EACA,IAAAf,GAAAlH,EAAAsI,wBAAA,IAAAtI,EAAAsI,sBAAA3L,EAAAG,EAAAwG,GACA+E,GAAA,EACGrI,EAAAuI,qBACHvI,EAAAuI,oBAAA5L,EAAAG,EAAAwG,GAEAtD,EAAArD,QACAqD,EAAAlD,QACAkD,EAAAsD,WAGAtD,EAAAyH,UAAAzH,EAAAgI,UAAAhI,EAAAwH,YAAAxH,EAAA+G,SAAA,KACA/G,EAAAC,QAAA,GAEAoI,EAAA,CACAT,EAAA5H,EAAA9B,OAAAvB,EAAAG,EAAAwG,GAGAtD,EAAAwI,kBACAlF,EAAA1D,OAA6B0D,GAAAtD,EAAAwI,mBAG7B,IACAC,GACApB,EAFAqB,EAAAd,KAAAjJ,QAIA,sBAAA+J,GAAA,CAGA,GAAAC,GAAA3H,EAAA4G,EACAf,GAAAuB,EAEAvB,KAAAvJ,cAAAoL,GAAAC,EAAAlJ,KAAAoH,EAAAf,MACAmB,EAAAJ,EAAA8B,EAAA,EAAArF,GAAA,IAEAmF,EAAA5B,EAEA7G,EAAAkE,WAAA2C,EAAAF,EAAA+B,EAAAC,EAAArF,GACAuD,EAAAE,SAAAF,EAAAE,YACAF,EAAA+B,iBAAA5I,EACAiH,EAAAJ,EAAA8B,EAAA,EAAArF,GAAA,GACA/C,EAAAsG,EAAA,EAAAtD,GAAA,IAGA8D,EAAAR,EAAAQ,SAEAQ,GAAAM,EAGAM,EAAAL,EACAK,IACAZ,EAAA7H,EAAAkE,WAAA,OAGAiE,GAAA,IAAAjB,KACAW,MAAA3D,WAAA,MACAmD,EAAAjE,EAAAyE,EAAAD,EAAAtE,EAAAC,IAAA2E,EAAAC,KAAA5G,YAAA,GAIA,IAAA4G,GAAAd,IAAAc,GAAAtB,IAAAuB,EAAA,CACA,GAAAS,GAAAV,EAAA5G,UACAsH,IAAAxB,IAAAwB,IACAA,EAAAxE,aAAAgD,EAAAc,GAEAM,IACAN,EAAAjE,WAAA,KACAI,EAAA6D,GAAA,KAUA,GALAM,GACAvC,EAAAuC,GAGAzI,EAAAqH,OACAA,IAAAM,EAAA,CAGA,IAFA,GAAAmB,GAAA9I,EACA+I,EAAA/I,EACA+I,IAAAH,mBACAE,EAAAC,GAAA1B,MAEAA,GAAAnD,WAAA4E,EACAzB,EAAAzG,sBAAAkI,EAAAxL,aAkBA,IAdA4K,GAAA3E,EACAN,EAAA3E,QAAA0B,GACEqI,IAMFrI,EAAAzC,oBACAyC,EAAAzC,mBAAAuK,EAAAC,EAAAE,GAEAvI,EAAAsJ,aAAAtJ,EAAAsJ,YAAAhJ,IAGA,MAAAA,EAAAiJ,iBACA,KAAAjJ,EAAAiJ,iBAAA9J,QACAa,EAAAiJ,iBAAA3J,MAAAjF,KAAA2F,EAIA0D,IAAAiE,GAAA3E,KASA,QAAAwB,GAAAnB,EAAA1D,EAAA2D,EAAAC,GAOA,IANA,GAAAhJ,GAAA8I,KAAAa,WACAgF,EAAA3O,EACA4O,EAAA9F,EACA+F,EAAA7O,GAAA8I,EAAAzC,wBAAAjB,EAAAhB,SACA0K,EAAAD,EACAzM,EAAAqE,EAAArB,GACApF,IAAA8O,IAAA9O,IAAAqO,mBACAS,EAAA9O,EAAA+C,cAAAqC,EAAAhB,QA2BA,OAxBApE,IAAA8O,KAAA9F,GAAAhJ,EAAA2J,aACA+C,EAAA1M,EAAAoC,EAAA,EAAA2G,EAAAC,GACAF,EAAA9I,EAAA8M,OAEA6B,IAAAE,IACAlD,EAAAgD,GACA7F,EAAA8F,EAAA,MAGA5O,EAAAoM,EAAAhH,EAAAhB,SAAAhC,EAAA2G,GACAD,IAAA9I,EAAAwM,WACAxM,EAAAwM,SAAA1D,EAEA8F,EAAA,MAEAlC,EAAA1M,EAAAoC,EAAA,EAAA2G,EAAAC,GACAF,EAAA9I,EAAA8M,KAEA8B,GAAA9F,IAAA8F,IACAA,EAAAjF,WAAA,KACAI,EAAA6E,GAAA,KAIA9F,EAOA,QAAA6C,GAAAlG,GACAN,EAAA4J,eAAA5J,EAAA4J,cAAAtJ,EAEA,IAAAqH,GAAArH,EAAAqH,IAEArH,GAAAmH,UAAA,EAEAnH,EAAAuJ,sBAAAvJ,EAAAuJ,uBAEAvJ,EAAAqH,KAAA,IAGA,IAAAmC,GAAAxJ,EAAAkE,UACAsF,GACAtD,EAAAsD,GACEnC,IACFA,EAAA,eAAAA,EAAA,cAAAlB,KAAAkB,EAAA,cAAAlB,IAAA,MAEAnG,EAAA+G,SAAAM,EAEA/F,EAAA+F,GACAZ,EAAAzG,GAEAoG,EAAAiB,IAGArH,EAAAoH,OAAApH,EAAAoH,MAAA,MAcA,QAAA1K,GAAAC,EAAA2G,GACAzG,KAAAoD,QAAA,EAKApD,KAAAyG,UAKAzG,KAAAF,QAKAE,KAAAC,MAAAD,KAAAC,UA8DA,QAAAoB,GAAAyB,EAAA6D,EAAAiG,GACA,MAAArG,GAAAqG,EAAA9J,MAA8B,EAAA6D,GAAA,GHtvBC1J,EAAoBU,EAAEiB,EAAqB,IAAK,WAAa,MAAOiB,IGvLnG,IAAAgD,MAwBAN,KAEAH,KAqEAmB,EAAA,kBAAAsJ,iBAAAC,UAAAC,KAAAnL,KAAAiL,QAAAC,WAAAE,WAOAhI,EAAA,yDAIA3B,KA4JA+C,KAGAS,EAAA,EAGAC,GAAA,EAGAjD,GAAA,EA6RAgG,IAqUA9G,GAAAlD,EAAArB,WAeAsC,SAAA,SAAAb,EAAAgN,GACA,GAAAtO,GAAAqB,KAAAC,KACAD,MAAAmL,YAAAnL,KAAAmL,UAAApI,KAAiDpE,IACjDoE,EAAApE,EAAA,kBAAAsB,KAAAtB,EAAAqB,KAAAF,OAAAG,GACAgN,IAAAjN,KAAAoM,iBAAApM,KAAAoM,sBAAA5J,KAAAyK,GACA/J,EAAAlD,OAQAkN,YAAA,SAAAD,GACAA,IAAAjN,KAAAoM,iBAAApM,KAAAoM,sBAAA5J,KAAAyK,GACAvJ,EAAA1D,KAAA,IAWAqB,OAAA,cAsBA,IAAA8L,IACA3L,IACAgD,cAAAhD,EACAyB,eACApD,YACAwB,SACAmC,WACAX,UAGqFjE,GAAA","file":"back-end.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */,\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_preact__ = __webpack_require__(2);\n\n\nvar config = {\n  DATA_ELEMENT: '_size_table_data',\n  CONTAINER_ELEMENT: 'size_table_container'\n}\n\nvar data = getData()\n\nvar Table = (function (Component) {\n  function Table (props) {\n    Component.call(this, props)\n    this.state = Object.assign({\n      sizes: ['S', 'M', 'L'],\n      rows: [\n        {\n          measure: 'Neck',\n          values: [20, 30, 40]\n        },\n        {\n          measure: 'Waist',\n          values: [10, 12, 14]\n        }\n      ]\n    }, this.props)\n  }\n\n  if ( Component ) Table.__proto__ = Component;\n  Table.prototype = Object.create( Component && Component.prototype );\n  Table.prototype.constructor = Table;\n  Table.prototype.componentDidUpdate = function componentDidUpdate () {\n    setData(this.state)\n  };\n  Table.prototype.addMeasure = function addMeasure () {\n    var rows = this.state.rows.concat( [{\n      measure: '',\n      values: []\n    }])\n\n    this.setState({ rows: rows })\n  };\n  Table.prototype.deleteMeasure = function deleteMeasure () {\n    var sizes = this.state.sizes.slice(0, -1)\n    var rows = this.state.rows.map(function (row) {\n      return Object.assign(row, {\n        values: row.values.slice(0, -1)\n      })\n    })\n\n    this.setState({ sizes: sizes, rows: rows })\n  };\n  Table.prototype.addSize = function addSize () {\n    var sizes = this.state.sizes.concat( [''])\n    var rows = this.state.rows.map(function (row) {\n      return Object.assign(row, {\n        values: row.values.concat( [''])\n      })\n    })\n\n    this.setState({ sizes: sizes, rows: rows })\n  };\n  Table.prototype.deleteSize = function deleteSize () {\n\n  };\n  Table.prototype.render = function render (props, state) {\n    var headings = state.sizes.map(function (size) { return __WEBPACK_IMPORTED_MODULE_0_preact__[\"b\" /* default */].h( 'th', null, size ); })\n    headings.unshift(__WEBPACK_IMPORTED_MODULE_0_preact__[\"b\" /* default */].h( 'th', null ))\n\n    var rows = state.rows.map(function (row) {\n      var values = row.values.map(function (size) { return __WEBPACK_IMPORTED_MODULE_0_preact__[\"b\" /* default */].h( 'td', null, size ); })\n      return (\n        __WEBPACK_IMPORTED_MODULE_0_preact__[\"b\" /* default */].h( 'tr', null,\n          __WEBPACK_IMPORTED_MODULE_0_preact__[\"b\" /* default */].h( 'td', null, row.measure ),\n          values\n        )\n      )\n    })\n\n    return (\n      __WEBPACK_IMPORTED_MODULE_0_preact__[\"b\" /* default */].h( 'div', null,\n        __WEBPACK_IMPORTED_MODULE_0_preact__[\"b\" /* default */].h( 'table', null,\n          __WEBPACK_IMPORTED_MODULE_0_preact__[\"b\" /* default */].h( 'tr', null, headings ),\n          rows\n        ),\n        __WEBPACK_IMPORTED_MODULE_0_preact__[\"b\" /* default */].h( 'div', { className: 'add-size', onClick: this.addSize.bind(this) }, \"Add size\"),\n        __WEBPACK_IMPORTED_MODULE_0_preact__[\"b\" /* default */].h( 'div', { className: 'add-measure', onClick: this.addMeasure.bind(this) }, \"Add measure\")\n      )\n    )\n  };\n\n  return Table;\n}(__WEBPACK_IMPORTED_MODULE_0_preact__[\"a\" /* Component */]));\n\n__WEBPACK_IMPORTED_MODULE_0_preact__[\"b\" /* default */].render(__WEBPACK_IMPORTED_MODULE_0_preact__[\"b\" /* default */].h( Table, { data: data }), document.getElementById(config.CONTAINER_ELEMENT))\n\nfunction setData (data) {\n  console.log('set data: ', data)\n  document.getElementById(config.DATA_ELEMENT).value = JSON.stringify(data)\n}\n\nfunction getData () {\n  try {\n    return JSON.parse(document.getElementById(config.DATA_ELEMENT).value)\n  } catch (e) {\n    return {}\n  }\n}\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export h */\n/* unused harmony export createElement */\n/* unused harmony export cloneElement */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Component; });\n/* unused harmony export render */\n/* unused harmony export rerender */\n/* unused harmony export options */\n/** Virtual DOM Node */\nfunction VNode() {}\n\n/** Global options\n *\t@public\n *\t@namespace options {Object}\n */\nvar options = {\n\n\t/** If `true`, `prop` changes trigger synchronous component updates.\n  *\t@name syncComponentUpdates\n  *\t@type Boolean\n  *\t@default true\n  */\n\t//syncComponentUpdates: true,\n\n\t/** Processes all created VNodes.\n  *\t@param {VNode} vnode\tA newly-created VNode to normalize/process\n  */\n\t//vnode(vnode) { }\n\n\t/** Hook invoked after a component is mounted. */\n\t// afterMount(component) { }\n\n\t/** Hook invoked after the DOM is updated with a component's latest render. */\n\t// afterUpdate(component) { }\n\n\t/** Hook invoked immediately before a component is unmounted. */\n\t// beforeUnmount(component) { }\n};\n\nvar stack = [];\n\nvar EMPTY_CHILDREN = [];\n\n/** JSX/hyperscript reviver\n*\tBenchmarks: https://esbench.com/bench/57ee8f8e330ab09900a1a1a0\n *\t@see http://jasonformat.com/wtf-is-jsx\n *\t@public\n */\nfunction h(nodeName, attributes) {\n\tvar children = EMPTY_CHILDREN,\n\t    lastSimple,\n\t    child,\n\t    simple,\n\t    i;\n\tfor (i = arguments.length; i-- > 2;) {\n\t\tstack.push(arguments[i]);\n\t}\n\tif (attributes && attributes.children != null) {\n\t\tif (!stack.length) stack.push(attributes.children);\n\t\tdelete attributes.children;\n\t}\n\twhile (stack.length) {\n\t\tif ((child = stack.pop()) && child.pop !== undefined) {\n\t\t\tfor (i = child.length; i--;) {\n\t\t\t\tstack.push(child[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (typeof child === 'boolean') child = null;\n\n\t\t\tif (simple = typeof nodeName !== 'function') {\n\t\t\t\tif (child == null) child = '';else if (typeof child === 'number') child = String(child);else if (typeof child !== 'string') simple = false;\n\t\t\t}\n\n\t\t\tif (simple && lastSimple) {\n\t\t\t\tchildren[children.length - 1] += child;\n\t\t\t} else if (children === EMPTY_CHILDREN) {\n\t\t\t\tchildren = [child];\n\t\t\t} else {\n\t\t\t\tchildren.push(child);\n\t\t\t}\n\n\t\t\tlastSimple = simple;\n\t\t}\n\t}\n\n\tvar p = new VNode();\n\tp.nodeName = nodeName;\n\tp.children = children;\n\tp.attributes = attributes == null ? undefined : attributes;\n\tp.key = attributes == null ? undefined : attributes.key;\n\n\t// if a \"vnode hook\" is defined, pass every created VNode to it\n\tif (options.vnode !== undefined) options.vnode(p);\n\n\treturn p;\n}\n\n/** Copy own-properties from `props` onto `obj`.\n *\t@returns obj\n *\t@private\n */\nfunction extend(obj, props) {\n  for (var i in props) {\n    obj[i] = props[i];\n  }return obj;\n}\n\n/** Call a function asynchronously, as soon as possible.\n *\t@param {Function} callback\n */\nvar defer = typeof Promise == 'function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;\n\nfunction cloneElement(vnode, props) {\n\treturn h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);\n}\n\n// DOM properties that should NOT have \"px\" added when numeric\nvar IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;\n\n/** Managed queue of dirty components to be re-rendered */\n\nvar items = [];\n\nfunction enqueueRender(component) {\n\tif (!component._dirty && (component._dirty = true) && items.push(component) == 1) {\n\t\t(options.debounceRendering || defer)(rerender);\n\t}\n}\n\nfunction rerender() {\n\tvar p,\n\t    list = items;\n\titems = [];\n\twhile (p = list.pop()) {\n\t\tif (p._dirty) renderComponent(p);\n\t}\n}\n\n/** Check if two nodes are equivalent.\n *\t@param {Element} node\n *\t@param {VNode} vnode\n *\t@private\n */\nfunction isSameNodeType(node, vnode, hydrating) {\n\tif (typeof vnode === 'string' || typeof vnode === 'number') {\n\t\treturn node.splitText !== undefined;\n\t}\n\tif (typeof vnode.nodeName === 'string') {\n\t\treturn !node._componentConstructor && isNamedNode(node, vnode.nodeName);\n\t}\n\treturn hydrating || node._componentConstructor === vnode.nodeName;\n}\n\n/** Check if an Element has a given normalized name.\n*\t@param {Element} node\n*\t@param {String} nodeName\n */\nfunction isNamedNode(node, nodeName) {\n\treturn node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();\n}\n\n/**\n * Reconstruct Component-style `props` from a VNode.\n * Ensures default/fallback values from `defaultProps`:\n * Own-properties of `defaultProps` not present in `vnode.attributes` are added.\n * @param {VNode} vnode\n * @returns {Object} props\n */\nfunction getNodeProps(vnode) {\n\tvar props = extend({}, vnode.attributes);\n\tprops.children = vnode.children;\n\n\tvar defaultProps = vnode.nodeName.defaultProps;\n\tif (defaultProps !== undefined) {\n\t\tfor (var i in defaultProps) {\n\t\t\tif (props[i] === undefined) {\n\t\t\t\tprops[i] = defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn props;\n}\n\n/** Create an element with the given nodeName.\n *\t@param {String} nodeName\n *\t@param {Boolean} [isSvg=false]\tIf `true`, creates an element within the SVG namespace.\n *\t@returns {Element} node\n */\nfunction createNode(nodeName, isSvg) {\n\tvar node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);\n\tnode.normalizedNodeName = nodeName;\n\treturn node;\n}\n\n/** Remove a child node from its parent if attached.\n *\t@param {Element} node\t\tThe node to remove\n */\nfunction removeNode(node) {\n\tvar parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n\n/** Set a named attribute on the given Node, with special behavior for some names and event handlers.\n *\tIf `value` is `null`, the attribute/handler will be removed.\n *\t@param {Element} node\tAn element to mutate\n *\t@param {string} name\tThe name/key to set, such as an event or attribute name\n *\t@param {any} old\tThe last value that was set for this name/node pair\n *\t@param {any} value\tAn attribute value, such as a function to be used as an event handler\n *\t@param {Boolean} isSvg\tAre we currently diffing inside an svg?\n *\t@private\n */\nfunction setAccessor(node, name, old, value, isSvg) {\n\tif (name === 'className') name = 'class';\n\n\tif (name === 'key') {\n\t\t// ignore\n\t} else if (name === 'ref') {\n\t\tif (old) old(null);\n\t\tif (value) value(node);\n\t} else if (name === 'class' && !isSvg) {\n\t\tnode.className = value || '';\n\t} else if (name === 'style') {\n\t\tif (!value || typeof value === 'string' || typeof old === 'string') {\n\t\t\tnode.style.cssText = value || '';\n\t\t}\n\t\tif (value && typeof value === 'object') {\n\t\t\tif (typeof old !== 'string') {\n\t\t\t\tfor (var i in old) {\n\t\t\t\t\tif (!(i in value)) node.style[i] = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i in value) {\n\t\t\t\tnode.style[i] = typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + 'px' : value[i];\n\t\t\t}\n\t\t}\n\t} else if (name === 'dangerouslySetInnerHTML') {\n\t\tif (value) node.innerHTML = value.__html || '';\n\t} else if (name[0] == 'o' && name[1] == 'n') {\n\t\tvar useCapture = name !== (name = name.replace(/Capture$/, ''));\n\t\tname = name.toLowerCase().substring(2);\n\t\tif (value) {\n\t\t\tif (!old) node.addEventListener(name, eventProxy, useCapture);\n\t\t} else {\n\t\t\tnode.removeEventListener(name, eventProxy, useCapture);\n\t\t}\n\t\t(node._listeners || (node._listeners = {}))[name] = value;\n\t} else if (name !== 'list' && name !== 'type' && !isSvg && name in node) {\n\t\tsetProperty(node, name, value == null ? '' : value);\n\t\tif (value == null || value === false) node.removeAttribute(name);\n\t} else {\n\t\tvar ns = isSvg && name !== (name = name.replace(/^xlink\\:?/, ''));\n\t\tif (value == null || value === false) {\n\t\t\tif (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());else node.removeAttribute(name);\n\t\t} else if (typeof value !== 'function') {\n\t\t\tif (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);else node.setAttribute(name, value);\n\t\t}\n\t}\n}\n\n/** Attempt to set a DOM property to the given value.\n *\tIE & FF throw for certain property-value combinations.\n */\nfunction setProperty(node, name, value) {\n\ttry {\n\t\tnode[name] = value;\n\t} catch (e) {}\n}\n\n/** Proxy an event to hooked event handlers\n *\t@private\n */\nfunction eventProxy(e) {\n\treturn this._listeners[e.type](options.event && options.event(e) || e);\n}\n\n/** Queue of components that have been mounted and are awaiting componentDidMount */\nvar mounts = [];\n\n/** Diff recursion count, used to track the end of the diff cycle. */\nvar diffLevel = 0;\n\n/** Global flag indicating if the diff is currently within an SVG */\nvar isSvgMode = false;\n\n/** Global flag indicating if the diff is performing hydration */\nvar hydrating = false;\n\n/** Invoke queued componentDidMount lifecycle methods */\nfunction flushMounts() {\n\tvar c;\n\twhile (c = mounts.pop()) {\n\t\tif (options.afterMount) options.afterMount(c);\n\t\tif (c.componentDidMount) c.componentDidMount();\n\t}\n}\n\n/** Apply differences in a given vnode (and it's deep children) to a real DOM Node.\n *\t@param {Element} [dom=null]\t\tA DOM node to mutate into the shape of the `vnode`\n *\t@param {VNode} vnode\t\t\tA VNode (with descendants forming a tree) representing the desired DOM structure\n *\t@returns {Element} dom\t\t\tThe created/mutated element\n *\t@private\n */\nfunction diff(dom, vnode, context, mountAll, parent, componentRoot) {\n\t// diffLevel having been 0 here indicates initial entry into the diff (not a subdiff)\n\tif (!diffLevel++) {\n\t\t// when first starting the diff, check if we're diffing an SVG or within an SVG\n\t\tisSvgMode = parent != null && parent.ownerSVGElement !== undefined;\n\n\t\t// hydration is indicated by the existing element to be diffed not having a prop cache\n\t\thydrating = dom != null && !('__preactattr_' in dom);\n\t}\n\n\tvar ret = idiff(dom, vnode, context, mountAll, componentRoot);\n\n\t// append the element if its a new parent\n\tif (parent && ret.parentNode !== parent) parent.appendChild(ret);\n\n\t// diffLevel being reduced to 0 means we're exiting the diff\n\tif (! --diffLevel) {\n\t\thydrating = false;\n\t\t// invoke queued componentDidMount lifecycle methods\n\t\tif (!componentRoot) flushMounts();\n\t}\n\n\treturn ret;\n}\n\n/** Internals of `diff()`, separated to allow bypassing diffLevel / mount flushing. */\nfunction idiff(dom, vnode, context, mountAll, componentRoot) {\n\tvar out = dom,\n\t    prevSvgMode = isSvgMode;\n\n\t// empty values (null, undefined, booleans) render as empty Text nodes\n\tif (vnode == null || typeof vnode === 'boolean') vnode = '';\n\n\t// Fast case: Strings & Numbers create/update Text nodes.\n\tif (typeof vnode === 'string' || typeof vnode === 'number') {\n\n\t\t// update if it's already a Text node:\n\t\tif (dom && dom.splitText !== undefined && dom.parentNode && (!dom._component || componentRoot)) {\n\t\t\t/* istanbul ignore if */ /* Browser quirk that can't be covered: https://github.com/developit/preact/commit/fd4f21f5c45dfd75151bd27b4c217d8003aa5eb9 */\n\t\t\tif (dom.nodeValue != vnode) {\n\t\t\t\tdom.nodeValue = vnode;\n\t\t\t}\n\t\t} else {\n\t\t\t// it wasn't a Text node: replace it with one and recycle the old Element\n\t\t\tout = document.createTextNode(vnode);\n\t\t\tif (dom) {\n\t\t\t\tif (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n\t\t\t\trecollectNodeTree(dom, true);\n\t\t\t}\n\t\t}\n\n\t\tout['__preactattr_'] = true;\n\n\t\treturn out;\n\t}\n\n\t// If the VNode represents a Component, perform a component diff:\n\tvar vnodeName = vnode.nodeName;\n\tif (typeof vnodeName === 'function') {\n\t\treturn buildComponentFromVNode(dom, vnode, context, mountAll);\n\t}\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tisSvgMode = vnodeName === 'svg' ? true : vnodeName === 'foreignObject' ? false : isSvgMode;\n\n\t// If there's no existing element or it's the wrong type, create a new one:\n\tvnodeName = String(vnodeName);\n\tif (!dom || !isNamedNode(dom, vnodeName)) {\n\t\tout = createNode(vnodeName, isSvgMode);\n\n\t\tif (dom) {\n\t\t\t// move children into the replacement node\n\t\t\twhile (dom.firstChild) {\n\t\t\t\tout.appendChild(dom.firstChild);\n\t\t\t} // if the previous Element was mounted into the DOM, replace it inline\n\t\t\tif (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n\n\t\t\t// recycle the old element (skips non-Element node types)\n\t\t\trecollectNodeTree(dom, true);\n\t\t}\n\t}\n\n\tvar fc = out.firstChild,\n\t    props = out['__preactattr_'],\n\t    vchildren = vnode.children;\n\n\tif (props == null) {\n\t\tprops = out['__preactattr_'] = {};\n\t\tfor (var a = out.attributes, i = a.length; i--;) {\n\t\t\tprops[a[i].name] = a[i].value;\n\t\t}\n\t}\n\n\t// Optimization: fast-path for elements containing a single TextNode:\n\tif (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === 'string' && fc != null && fc.splitText !== undefined && fc.nextSibling == null) {\n\t\tif (fc.nodeValue != vchildren[0]) {\n\t\t\tfc.nodeValue = vchildren[0];\n\t\t}\n\t}\n\t// otherwise, if there are existing or new children, diff them:\n\telse if (vchildren && vchildren.length || fc != null) {\n\t\t\tinnerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML != null);\n\t\t}\n\n\t// Apply attributes/props from VNode to the DOM Element:\n\tdiffAttributes(out, vnode.attributes, props);\n\n\t// restore previous SVG mode: (in case we're exiting an SVG namespace)\n\tisSvgMode = prevSvgMode;\n\n\treturn out;\n}\n\n/** Apply child and attribute changes between a VNode and a DOM Node to the DOM.\n *\t@param {Element} dom\t\t\tElement whose children should be compared & mutated\n *\t@param {Array} vchildren\t\tArray of VNodes to compare to `dom.childNodes`\n *\t@param {Object} context\t\t\tImplicitly descendant context object (from most recent `getChildContext()`)\n *\t@param {Boolean} mountAll\n *\t@param {Boolean} isHydrating\tIf `true`, consumes externally created elements similar to hydration\n */\nfunction innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {\n\tvar originalChildren = dom.childNodes,\n\t    children = [],\n\t    keyed = {},\n\t    keyedLen = 0,\n\t    min = 0,\n\t    len = originalChildren.length,\n\t    childrenLen = 0,\n\t    vlen = vchildren ? vchildren.length : 0,\n\t    j,\n\t    c,\n\t    f,\n\t    vchild,\n\t    child;\n\n\t// Build up a map of keyed children and an Array of unkeyed children:\n\tif (len !== 0) {\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar _child = originalChildren[i],\n\t\t\t    props = _child['__preactattr_'],\n\t\t\t    key = vlen && props ? _child._component ? _child._component.__key : props.key : null;\n\t\t\tif (key != null) {\n\t\t\t\tkeyedLen++;\n\t\t\t\tkeyed[key] = _child;\n\t\t\t} else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {\n\t\t\t\tchildren[childrenLen++] = _child;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (vlen !== 0) {\n\t\tfor (var i = 0; i < vlen; i++) {\n\t\t\tvchild = vchildren[i];\n\t\t\tchild = null;\n\n\t\t\t// attempt to find a node based on key matching\n\t\t\tvar key = vchild.key;\n\t\t\tif (key != null) {\n\t\t\t\tif (keyedLen && keyed[key] !== undefined) {\n\t\t\t\t\tchild = keyed[key];\n\t\t\t\t\tkeyed[key] = undefined;\n\t\t\t\t\tkeyedLen--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// attempt to pluck a node of the same type from the existing children\n\t\t\telse if (!child && min < childrenLen) {\n\t\t\t\t\tfor (j = min; j < childrenLen; j++) {\n\t\t\t\t\t\tif (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {\n\t\t\t\t\t\t\tchild = c;\n\t\t\t\t\t\t\tchildren[j] = undefined;\n\t\t\t\t\t\t\tif (j === childrenLen - 1) childrenLen--;\n\t\t\t\t\t\t\tif (j === min) min++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// morph the matched/found/created DOM child to match vchild (deep)\n\t\t\tchild = idiff(child, vchild, context, mountAll);\n\n\t\t\tf = originalChildren[i];\n\t\t\tif (child && child !== dom && child !== f) {\n\t\t\t\tif (f == null) {\n\t\t\t\t\tdom.appendChild(child);\n\t\t\t\t} else if (child === f.nextSibling) {\n\t\t\t\t\tremoveNode(f);\n\t\t\t\t} else {\n\t\t\t\t\tdom.insertBefore(child, f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// remove unused keyed children:\n\tif (keyedLen) {\n\t\tfor (var i in keyed) {\n\t\t\tif (keyed[i] !== undefined) recollectNodeTree(keyed[i], false);\n\t\t}\n\t}\n\n\t// remove orphaned unkeyed children:\n\twhile (min <= childrenLen) {\n\t\tif ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);\n\t}\n}\n\n/** Recursively recycle (or just unmount) a node and its descendants.\n *\t@param {Node} node\t\t\t\t\t\tDOM node to start unmount/removal from\n *\t@param {Boolean} [unmountOnly=false]\tIf `true`, only triggers unmount lifecycle, skips removal\n */\nfunction recollectNodeTree(node, unmountOnly) {\n\tvar component = node._component;\n\tif (component) {\n\t\t// if node is owned by a Component, unmount that component (ends up recursing back here)\n\t\tunmountComponent(component);\n\t} else {\n\t\t// If the node's VNode had a ref function, invoke it with null here.\n\t\t// (this is part of the React spec, and smart for unsetting references)\n\t\tif (node['__preactattr_'] != null && node['__preactattr_'].ref) node['__preactattr_'].ref(null);\n\n\t\tif (unmountOnly === false || node['__preactattr_'] == null) {\n\t\t\tremoveNode(node);\n\t\t}\n\n\t\tremoveChildren(node);\n\t}\n}\n\n/** Recollect/unmount all children.\n *\t- we use .lastChild here because it causes less reflow than .firstChild\n *\t- it's also cheaper than accessing the .childNodes Live NodeList\n */\nfunction removeChildren(node) {\n\tnode = node.lastChild;\n\twhile (node) {\n\t\tvar next = node.previousSibling;\n\t\trecollectNodeTree(node, true);\n\t\tnode = next;\n\t}\n}\n\n/** Apply differences in attributes from a VNode to the given DOM Element.\n *\t@param {Element} dom\t\tElement with attributes to diff `attrs` against\n *\t@param {Object} attrs\t\tThe desired end-state key-value attribute pairs\n *\t@param {Object} old\t\t\tCurrent/previous attributes (from previous VNode or element's prop cache)\n */\nfunction diffAttributes(dom, attrs, old) {\n\tvar name;\n\n\t// remove attributes no longer present on the vnode by setting them to undefined\n\tfor (name in old) {\n\t\tif (!(attrs && attrs[name] != null) && old[name] != null) {\n\t\t\tsetAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);\n\t\t}\n\t}\n\n\t// add new & update changed attributes\n\tfor (name in attrs) {\n\t\tif (name !== 'children' && name !== 'innerHTML' && (!(name in old) || attrs[name] !== (name === 'value' || name === 'checked' ? dom[name] : old[name]))) {\n\t\t\tsetAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);\n\t\t}\n\t}\n}\n\n/** Retains a pool of Components for re-use, keyed on component name.\n *\tNote: since component names are not unique or even necessarily available, these are primarily a form of sharding.\n *\t@private\n */\nvar components = {};\n\n/** Reclaim a component for later re-use by the recycler. */\nfunction collectComponent(component) {\n\tvar name = component.constructor.name;\n\t(components[name] || (components[name] = [])).push(component);\n}\n\n/** Create a component. Normalizes differences between PFC's and classful Components. */\nfunction createComponent(Ctor, props, context) {\n\tvar list = components[Ctor.name],\n\t    inst;\n\n\tif (Ctor.prototype && Ctor.prototype.render) {\n\t\tinst = new Ctor(props, context);\n\t\tComponent.call(inst, props, context);\n\t} else {\n\t\tinst = new Component(props, context);\n\t\tinst.constructor = Ctor;\n\t\tinst.render = doRender;\n\t}\n\n\tif (list) {\n\t\tfor (var i = list.length; i--;) {\n\t\t\tif (list[i].constructor === Ctor) {\n\t\t\t\tinst.nextBase = list[i].nextBase;\n\t\t\t\tlist.splice(i, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn inst;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n\n/** Set a component's `props` (generally derived from JSX attributes).\n *\t@param {Object} props\n *\t@param {Object} [opts]\n *\t@param {boolean} [opts.renderSync=false]\tIf `true` and {@link options.syncComponentUpdates} is `true`, triggers synchronous rendering.\n *\t@param {boolean} [opts.render=true]\t\t\tIf `false`, no render will be triggered.\n */\nfunction setComponentProps(component, props, opts, context, mountAll) {\n\tif (component._disable) return;\n\tcomponent._disable = true;\n\n\tif (component.__ref = props.ref) delete props.ref;\n\tif (component.__key = props.key) delete props.key;\n\n\tif (!component.base || mountAll) {\n\t\tif (component.componentWillMount) component.componentWillMount();\n\t} else if (component.componentWillReceiveProps) {\n\t\tcomponent.componentWillReceiveProps(props, context);\n\t}\n\n\tif (context && context !== component.context) {\n\t\tif (!component.prevContext) component.prevContext = component.context;\n\t\tcomponent.context = context;\n\t}\n\n\tif (!component.prevProps) component.prevProps = component.props;\n\tcomponent.props = props;\n\n\tcomponent._disable = false;\n\n\tif (opts !== 0) {\n\t\tif (opts === 1 || options.syncComponentUpdates !== false || !component.base) {\n\t\t\trenderComponent(component, 1, mountAll);\n\t\t} else {\n\t\t\tenqueueRender(component);\n\t\t}\n\t}\n\n\tif (component.__ref) component.__ref(component);\n}\n\n/** Render a Component, triggering necessary lifecycle events and taking High-Order Components into account.\n *\t@param {Component} component\n *\t@param {Object} [opts]\n *\t@param {boolean} [opts.build=false]\t\tIf `true`, component will build and store a DOM node if not already associated with one.\n *\t@private\n */\nfunction renderComponent(component, opts, mountAll, isChild) {\n\tif (component._disable) return;\n\n\tvar props = component.props,\n\t    state = component.state,\n\t    context = component.context,\n\t    previousProps = component.prevProps || props,\n\t    previousState = component.prevState || state,\n\t    previousContext = component.prevContext || context,\n\t    isUpdate = component.base,\n\t    nextBase = component.nextBase,\n\t    initialBase = isUpdate || nextBase,\n\t    initialChildComponent = component._component,\n\t    skip = false,\n\t    rendered,\n\t    inst,\n\t    cbase;\n\n\t// if updating\n\tif (isUpdate) {\n\t\tcomponent.props = previousProps;\n\t\tcomponent.state = previousState;\n\t\tcomponent.context = previousContext;\n\t\tif (opts !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {\n\t\t\tskip = true;\n\t\t} else if (component.componentWillUpdate) {\n\t\t\tcomponent.componentWillUpdate(props, state, context);\n\t\t}\n\t\tcomponent.props = props;\n\t\tcomponent.state = state;\n\t\tcomponent.context = context;\n\t}\n\n\tcomponent.prevProps = component.prevState = component.prevContext = component.nextBase = null;\n\tcomponent._dirty = false;\n\n\tif (!skip) {\n\t\trendered = component.render(props, state, context);\n\n\t\t// context to pass to the child, can be updated via (grand-)parent component\n\t\tif (component.getChildContext) {\n\t\t\tcontext = extend(extend({}, context), component.getChildContext());\n\t\t}\n\n\t\tvar childComponent = rendered && rendered.nodeName,\n\t\t    toUnmount,\n\t\t    base;\n\n\t\tif (typeof childComponent === 'function') {\n\t\t\t// set up high order component link\n\n\t\t\tvar childProps = getNodeProps(rendered);\n\t\t\tinst = initialChildComponent;\n\n\t\t\tif (inst && inst.constructor === childComponent && childProps.key == inst.__key) {\n\t\t\t\tsetComponentProps(inst, childProps, 1, context, false);\n\t\t\t} else {\n\t\t\t\ttoUnmount = inst;\n\n\t\t\t\tcomponent._component = inst = createComponent(childComponent, childProps, context);\n\t\t\t\tinst.nextBase = inst.nextBase || nextBase;\n\t\t\t\tinst._parentComponent = component;\n\t\t\t\tsetComponentProps(inst, childProps, 0, context, false);\n\t\t\t\trenderComponent(inst, 1, mountAll, true);\n\t\t\t}\n\n\t\t\tbase = inst.base;\n\t\t} else {\n\t\t\tcbase = initialBase;\n\n\t\t\t// destroy high order component link\n\t\t\ttoUnmount = initialChildComponent;\n\t\t\tif (toUnmount) {\n\t\t\t\tcbase = component._component = null;\n\t\t\t}\n\n\t\t\tif (initialBase || opts === 1) {\n\t\t\t\tif (cbase) cbase._component = null;\n\t\t\t\tbase = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);\n\t\t\t}\n\t\t}\n\n\t\tif (initialBase && base !== initialBase && inst !== initialChildComponent) {\n\t\t\tvar baseParent = initialBase.parentNode;\n\t\t\tif (baseParent && base !== baseParent) {\n\t\t\t\tbaseParent.replaceChild(base, initialBase);\n\n\t\t\t\tif (!toUnmount) {\n\t\t\t\t\tinitialBase._component = null;\n\t\t\t\t\trecollectNodeTree(initialBase, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (toUnmount) {\n\t\t\tunmountComponent(toUnmount);\n\t\t}\n\n\t\tcomponent.base = base;\n\t\tif (base && !isChild) {\n\t\t\tvar componentRef = component,\n\t\t\t    t = component;\n\t\t\twhile (t = t._parentComponent) {\n\t\t\t\t(componentRef = t).base = base;\n\t\t\t}\n\t\t\tbase._component = componentRef;\n\t\t\tbase._componentConstructor = componentRef.constructor;\n\t\t}\n\t}\n\n\tif (!isUpdate || mountAll) {\n\t\tmounts.unshift(component);\n\t} else if (!skip) {\n\t\t// Ensure that pending componentDidMount() hooks of child components\n\t\t// are called before the componentDidUpdate() hook in the parent.\n\t\t// Note: disabled as it causes duplicate hooks, see https://github.com/developit/preact/issues/750\n\t\t// flushMounts();\n\n\t\tif (component.componentDidUpdate) {\n\t\t\tcomponent.componentDidUpdate(previousProps, previousState, previousContext);\n\t\t}\n\t\tif (options.afterUpdate) options.afterUpdate(component);\n\t}\n\n\tif (component._renderCallbacks != null) {\n\t\twhile (component._renderCallbacks.length) {\n\t\t\tcomponent._renderCallbacks.pop().call(component);\n\t\t}\n\t}\n\n\tif (!diffLevel && !isChild) flushMounts();\n}\n\n/** Apply the Component referenced by a VNode to the DOM.\n *\t@param {Element} dom\tThe DOM node to mutate\n *\t@param {VNode} vnode\tA Component-referencing VNode\n *\t@returns {Element} dom\tThe created/mutated element\n *\t@private\n */\nfunction buildComponentFromVNode(dom, vnode, context, mountAll) {\n\tvar c = dom && dom._component,\n\t    originalComponent = c,\n\t    oldDom = dom,\n\t    isDirectOwner = c && dom._componentConstructor === vnode.nodeName,\n\t    isOwner = isDirectOwner,\n\t    props = getNodeProps(vnode);\n\twhile (c && !isOwner && (c = c._parentComponent)) {\n\t\tisOwner = c.constructor === vnode.nodeName;\n\t}\n\n\tif (c && isOwner && (!mountAll || c._component)) {\n\t\tsetComponentProps(c, props, 3, context, mountAll);\n\t\tdom = c.base;\n\t} else {\n\t\tif (originalComponent && !isDirectOwner) {\n\t\t\tunmountComponent(originalComponent);\n\t\t\tdom = oldDom = null;\n\t\t}\n\n\t\tc = createComponent(vnode.nodeName, props, context);\n\t\tif (dom && !c.nextBase) {\n\t\t\tc.nextBase = dom;\n\t\t\t// passing dom/oldDom as nextBase will recycle it if unused, so bypass recycling on L229:\n\t\t\toldDom = null;\n\t\t}\n\t\tsetComponentProps(c, props, 1, context, mountAll);\n\t\tdom = c.base;\n\n\t\tif (oldDom && dom !== oldDom) {\n\t\t\toldDom._component = null;\n\t\t\trecollectNodeTree(oldDom, false);\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/** Remove a component from the DOM and recycle it.\n *\t@param {Component} component\tThe Component instance to unmount\n *\t@private\n */\nfunction unmountComponent(component) {\n\tif (options.beforeUnmount) options.beforeUnmount(component);\n\n\tvar base = component.base;\n\n\tcomponent._disable = true;\n\n\tif (component.componentWillUnmount) component.componentWillUnmount();\n\n\tcomponent.base = null;\n\n\t// recursively tear down & recollect high-order component children:\n\tvar inner = component._component;\n\tif (inner) {\n\t\tunmountComponent(inner);\n\t} else if (base) {\n\t\tif (base['__preactattr_'] && base['__preactattr_'].ref) base['__preactattr_'].ref(null);\n\n\t\tcomponent.nextBase = base;\n\n\t\tremoveNode(base);\n\t\tcollectComponent(component);\n\n\t\tremoveChildren(base);\n\t}\n\n\tif (component.__ref) component.__ref(null);\n}\n\n/** Base Component class.\n *\tProvides `setState()` and `forceUpdate()`, which trigger rendering.\n *\t@public\n *\n *\t@example\n *\tclass MyFoo extends Component {\n *\t\trender(props, state) {\n *\t\t\treturn <div />;\n *\t\t}\n *\t}\n */\nfunction Component(props, context) {\n\tthis._dirty = true;\n\n\t/** @public\n  *\t@type {object}\n  */\n\tthis.context = context;\n\n\t/** @public\n  *\t@type {object}\n  */\n\tthis.props = props;\n\n\t/** @public\n  *\t@type {object}\n  */\n\tthis.state = this.state || {};\n}\n\nextend(Component.prototype, {\n\n\t/** Returns a `boolean` indicating if the component should re-render when receiving the given `props` and `state`.\n  *\t@param {object} nextProps\n  *\t@param {object} nextState\n  *\t@param {object} nextContext\n  *\t@returns {Boolean} should the component re-render\n  *\t@name shouldComponentUpdate\n  *\t@function\n  */\n\n\t/** Update component state by copying properties from `state` to `this.state`.\n  *\t@param {object} state\t\tA hash of state properties to update with new values\n  *\t@param {function} callback\tA function to be called once component state is updated\n  */\n\tsetState: function setState(state, callback) {\n\t\tvar s = this.state;\n\t\tif (!this.prevState) this.prevState = extend({}, s);\n\t\textend(s, typeof state === 'function' ? state(s, this.props) : state);\n\t\tif (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);\n\t\tenqueueRender(this);\n\t},\n\n\n\t/** Immediately perform a synchronous re-render of the component.\n  *\t@param {function} callback\t\tA function to be called after component is re-rendered.\n  *\t@private\n  */\n\tforceUpdate: function forceUpdate(callback) {\n\t\tif (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);\n\t\trenderComponent(this, 2);\n\t},\n\n\n\t/** Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n  *\tVirtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n  *\t@param {object} props\t\tProps (eg: JSX attributes) received from parent element/component\n  *\t@param {object} state\t\tThe component's current state\n  *\t@param {object} context\t\tContext object (if a parent component has provided context)\n  *\t@returns VNode\n  */\n\trender: function render() {}\n});\n\n/** Render JSX into a `parent` Element.\n *\t@param {VNode} vnode\t\tA (JSX) VNode to render\n *\t@param {Element} parent\t\tDOM element to render into\n *\t@param {Element} [merge]\tAttempt to re-use an existing DOM tree rooted at `merge`\n *\t@public\n *\n *\t@example\n *\t// render a div into <body>:\n *\trender(<div id=\"hello\">hello!</div>, document.body);\n *\n *\t@example\n *\t// render a \"Thing\" component into #foo:\n *\tconst Thing = ({ name }) => <span>{ name }</span>;\n *\trender(<Thing name=\"one\" />, document.querySelector('#foo'));\n */\nfunction render(vnode, parent, merge) {\n  return diff(merge, vnode, {}, false, parent, false);\n}\n\nvar preact = {\n\th: h,\n\tcreateElement: h,\n\tcloneElement: cloneElement,\n\tComponent: Component,\n\trender: render,\n\trerender: rerender,\n\toptions: options\n};\n\n/* harmony default export */ __webpack_exports__[\"b\"] = (preact);\n//# sourceMappingURL=preact.esm.js.map\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// back-end.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1f347d02cb19b7e701b5","import React, { Component } from 'preact'\n\nconst config = {\n  DATA_ELEMENT: '_size_table_data',\n  CONTAINER_ELEMENT: 'size_table_container'\n}\n\nconst data = getData()\n\nclass Table extends Component {\n  constructor (props) {\n    super(props)\n    this.state = Object.assign({\n      sizes: ['S', 'M', 'L'],\n      rows: [\n        {\n          measure: 'Neck',\n          values: [20, 30, 40]\n        },\n        {\n          measure: 'Waist',\n          values: [10, 12, 14]\n        }\n      ]\n    }, this.props)\n  }\n  componentDidUpdate () {\n    setData(this.state)\n  }\n  addMeasure () {\n    const rows = [...this.state.rows, {\n      measure: '',\n      values: []\n    }]\n\n    this.setState({ rows })\n  }\n  deleteMeasure () {\n    const sizes = this.state.sizes.slice(0, -1)\n    const rows = this.state.rows.map(row => {\n      return Object.assign(row, {\n        values: row.values.slice(0, -1)\n      })\n    })\n\n    this.setState({ sizes, rows })\n  }\n  addSize () {\n    const sizes = [...this.state.sizes, '']\n    const rows = this.state.rows.map(row => {\n      return Object.assign(row, {\n        values: [...row.values, '']\n      })\n    })\n\n    this.setState({ sizes, rows })\n  }\n  deleteSize () {\n\n  }\n  render (props, state) {\n    const headings = state.sizes.map(size => <th>{size}</th>)\n    headings.unshift(<th />)\n\n    const rows = state.rows.map(row => {\n      const values = row.values.map(size => <td>{size}</td>)\n      return (\n        <tr>\n          <td>{row.measure}</td>\n          {values}\n        </tr>\n      )\n    })\n\n    return (\n      <div>\n        <table>\n          <tr>{headings}</tr>\n          {rows}\n        </table>\n        <div className='add-size' onClick={this.addSize.bind(this)}>Add size</div>\n        <div className='add-measure' onClick={this.addMeasure.bind(this)}>Add measure</div>\n      </div>\n    )\n  }\n}\n\nReact.render(<Table data={data} />, document.getElementById(config.CONTAINER_ELEMENT))\n\nfunction setData (data) {\n  console.log('set data: ', data)\n  document.getElementById(config.DATA_ELEMENT).value = JSON.stringify(data)\n}\n\nfunction getData () {\n  try {\n    return JSON.parse(document.getElementById(config.DATA_ELEMENT).value)\n  } catch (e) {\n    return {}\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./back-end/js/index.jsx","/** Virtual DOM Node */\nfunction VNode() {}\n\n/** Global options\n *\t@public\n *\t@namespace options {Object}\n */\nvar options = {\n\n\t/** If `true`, `prop` changes trigger synchronous component updates.\n  *\t@name syncComponentUpdates\n  *\t@type Boolean\n  *\t@default true\n  */\n\t//syncComponentUpdates: true,\n\n\t/** Processes all created VNodes.\n  *\t@param {VNode} vnode\tA newly-created VNode to normalize/process\n  */\n\t//vnode(vnode) { }\n\n\t/** Hook invoked after a component is mounted. */\n\t// afterMount(component) { }\n\n\t/** Hook invoked after the DOM is updated with a component's latest render. */\n\t// afterUpdate(component) { }\n\n\t/** Hook invoked immediately before a component is unmounted. */\n\t// beforeUnmount(component) { }\n};\n\nvar stack = [];\n\nvar EMPTY_CHILDREN = [];\n\n/** JSX/hyperscript reviver\n*\tBenchmarks: https://esbench.com/bench/57ee8f8e330ab09900a1a1a0\n *\t@see http://jasonformat.com/wtf-is-jsx\n *\t@public\n */\nfunction h(nodeName, attributes) {\n\tvar children = EMPTY_CHILDREN,\n\t    lastSimple,\n\t    child,\n\t    simple,\n\t    i;\n\tfor (i = arguments.length; i-- > 2;) {\n\t\tstack.push(arguments[i]);\n\t}\n\tif (attributes && attributes.children != null) {\n\t\tif (!stack.length) stack.push(attributes.children);\n\t\tdelete attributes.children;\n\t}\n\twhile (stack.length) {\n\t\tif ((child = stack.pop()) && child.pop !== undefined) {\n\t\t\tfor (i = child.length; i--;) {\n\t\t\t\tstack.push(child[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (typeof child === 'boolean') child = null;\n\n\t\t\tif (simple = typeof nodeName !== 'function') {\n\t\t\t\tif (child == null) child = '';else if (typeof child === 'number') child = String(child);else if (typeof child !== 'string') simple = false;\n\t\t\t}\n\n\t\t\tif (simple && lastSimple) {\n\t\t\t\tchildren[children.length - 1] += child;\n\t\t\t} else if (children === EMPTY_CHILDREN) {\n\t\t\t\tchildren = [child];\n\t\t\t} else {\n\t\t\t\tchildren.push(child);\n\t\t\t}\n\n\t\t\tlastSimple = simple;\n\t\t}\n\t}\n\n\tvar p = new VNode();\n\tp.nodeName = nodeName;\n\tp.children = children;\n\tp.attributes = attributes == null ? undefined : attributes;\n\tp.key = attributes == null ? undefined : attributes.key;\n\n\t// if a \"vnode hook\" is defined, pass every created VNode to it\n\tif (options.vnode !== undefined) options.vnode(p);\n\n\treturn p;\n}\n\n/** Copy own-properties from `props` onto `obj`.\n *\t@returns obj\n *\t@private\n */\nfunction extend(obj, props) {\n  for (var i in props) {\n    obj[i] = props[i];\n  }return obj;\n}\n\n/** Call a function asynchronously, as soon as possible.\n *\t@param {Function} callback\n */\nvar defer = typeof Promise == 'function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;\n\nfunction cloneElement(vnode, props) {\n\treturn h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);\n}\n\n// DOM properties that should NOT have \"px\" added when numeric\nvar IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;\n\n/** Managed queue of dirty components to be re-rendered */\n\nvar items = [];\n\nfunction enqueueRender(component) {\n\tif (!component._dirty && (component._dirty = true) && items.push(component) == 1) {\n\t\t(options.debounceRendering || defer)(rerender);\n\t}\n}\n\nfunction rerender() {\n\tvar p,\n\t    list = items;\n\titems = [];\n\twhile (p = list.pop()) {\n\t\tif (p._dirty) renderComponent(p);\n\t}\n}\n\n/** Check if two nodes are equivalent.\n *\t@param {Element} node\n *\t@param {VNode} vnode\n *\t@private\n */\nfunction isSameNodeType(node, vnode, hydrating) {\n\tif (typeof vnode === 'string' || typeof vnode === 'number') {\n\t\treturn node.splitText !== undefined;\n\t}\n\tif (typeof vnode.nodeName === 'string') {\n\t\treturn !node._componentConstructor && isNamedNode(node, vnode.nodeName);\n\t}\n\treturn hydrating || node._componentConstructor === vnode.nodeName;\n}\n\n/** Check if an Element has a given normalized name.\n*\t@param {Element} node\n*\t@param {String} nodeName\n */\nfunction isNamedNode(node, nodeName) {\n\treturn node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();\n}\n\n/**\n * Reconstruct Component-style `props` from a VNode.\n * Ensures default/fallback values from `defaultProps`:\n * Own-properties of `defaultProps` not present in `vnode.attributes` are added.\n * @param {VNode} vnode\n * @returns {Object} props\n */\nfunction getNodeProps(vnode) {\n\tvar props = extend({}, vnode.attributes);\n\tprops.children = vnode.children;\n\n\tvar defaultProps = vnode.nodeName.defaultProps;\n\tif (defaultProps !== undefined) {\n\t\tfor (var i in defaultProps) {\n\t\t\tif (props[i] === undefined) {\n\t\t\t\tprops[i] = defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn props;\n}\n\n/** Create an element with the given nodeName.\n *\t@param {String} nodeName\n *\t@param {Boolean} [isSvg=false]\tIf `true`, creates an element within the SVG namespace.\n *\t@returns {Element} node\n */\nfunction createNode(nodeName, isSvg) {\n\tvar node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);\n\tnode.normalizedNodeName = nodeName;\n\treturn node;\n}\n\n/** Remove a child node from its parent if attached.\n *\t@param {Element} node\t\tThe node to remove\n */\nfunction removeNode(node) {\n\tvar parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n\n/** Set a named attribute on the given Node, with special behavior for some names and event handlers.\n *\tIf `value` is `null`, the attribute/handler will be removed.\n *\t@param {Element} node\tAn element to mutate\n *\t@param {string} name\tThe name/key to set, such as an event or attribute name\n *\t@param {any} old\tThe last value that was set for this name/node pair\n *\t@param {any} value\tAn attribute value, such as a function to be used as an event handler\n *\t@param {Boolean} isSvg\tAre we currently diffing inside an svg?\n *\t@private\n */\nfunction setAccessor(node, name, old, value, isSvg) {\n\tif (name === 'className') name = 'class';\n\n\tif (name === 'key') {\n\t\t// ignore\n\t} else if (name === 'ref') {\n\t\tif (old) old(null);\n\t\tif (value) value(node);\n\t} else if (name === 'class' && !isSvg) {\n\t\tnode.className = value || '';\n\t} else if (name === 'style') {\n\t\tif (!value || typeof value === 'string' || typeof old === 'string') {\n\t\t\tnode.style.cssText = value || '';\n\t\t}\n\t\tif (value && typeof value === 'object') {\n\t\t\tif (typeof old !== 'string') {\n\t\t\t\tfor (var i in old) {\n\t\t\t\t\tif (!(i in value)) node.style[i] = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i in value) {\n\t\t\t\tnode.style[i] = typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + 'px' : value[i];\n\t\t\t}\n\t\t}\n\t} else if (name === 'dangerouslySetInnerHTML') {\n\t\tif (value) node.innerHTML = value.__html || '';\n\t} else if (name[0] == 'o' && name[1] == 'n') {\n\t\tvar useCapture = name !== (name = name.replace(/Capture$/, ''));\n\t\tname = name.toLowerCase().substring(2);\n\t\tif (value) {\n\t\t\tif (!old) node.addEventListener(name, eventProxy, useCapture);\n\t\t} else {\n\t\t\tnode.removeEventListener(name, eventProxy, useCapture);\n\t\t}\n\t\t(node._listeners || (node._listeners = {}))[name] = value;\n\t} else if (name !== 'list' && name !== 'type' && !isSvg && name in node) {\n\t\tsetProperty(node, name, value == null ? '' : value);\n\t\tif (value == null || value === false) node.removeAttribute(name);\n\t} else {\n\t\tvar ns = isSvg && name !== (name = name.replace(/^xlink\\:?/, ''));\n\t\tif (value == null || value === false) {\n\t\t\tif (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());else node.removeAttribute(name);\n\t\t} else if (typeof value !== 'function') {\n\t\t\tif (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);else node.setAttribute(name, value);\n\t\t}\n\t}\n}\n\n/** Attempt to set a DOM property to the given value.\n *\tIE & FF throw for certain property-value combinations.\n */\nfunction setProperty(node, name, value) {\n\ttry {\n\t\tnode[name] = value;\n\t} catch (e) {}\n}\n\n/** Proxy an event to hooked event handlers\n *\t@private\n */\nfunction eventProxy(e) {\n\treturn this._listeners[e.type](options.event && options.event(e) || e);\n}\n\n/** Queue of components that have been mounted and are awaiting componentDidMount */\nvar mounts = [];\n\n/** Diff recursion count, used to track the end of the diff cycle. */\nvar diffLevel = 0;\n\n/** Global flag indicating if the diff is currently within an SVG */\nvar isSvgMode = false;\n\n/** Global flag indicating if the diff is performing hydration */\nvar hydrating = false;\n\n/** Invoke queued componentDidMount lifecycle methods */\nfunction flushMounts() {\n\tvar c;\n\twhile (c = mounts.pop()) {\n\t\tif (options.afterMount) options.afterMount(c);\n\t\tif (c.componentDidMount) c.componentDidMount();\n\t}\n}\n\n/** Apply differences in a given vnode (and it's deep children) to a real DOM Node.\n *\t@param {Element} [dom=null]\t\tA DOM node to mutate into the shape of the `vnode`\n *\t@param {VNode} vnode\t\t\tA VNode (with descendants forming a tree) representing the desired DOM structure\n *\t@returns {Element} dom\t\t\tThe created/mutated element\n *\t@private\n */\nfunction diff(dom, vnode, context, mountAll, parent, componentRoot) {\n\t// diffLevel having been 0 here indicates initial entry into the diff (not a subdiff)\n\tif (!diffLevel++) {\n\t\t// when first starting the diff, check if we're diffing an SVG or within an SVG\n\t\tisSvgMode = parent != null && parent.ownerSVGElement !== undefined;\n\n\t\t// hydration is indicated by the existing element to be diffed not having a prop cache\n\t\thydrating = dom != null && !('__preactattr_' in dom);\n\t}\n\n\tvar ret = idiff(dom, vnode, context, mountAll, componentRoot);\n\n\t// append the element if its a new parent\n\tif (parent && ret.parentNode !== parent) parent.appendChild(ret);\n\n\t// diffLevel being reduced to 0 means we're exiting the diff\n\tif (! --diffLevel) {\n\t\thydrating = false;\n\t\t// invoke queued componentDidMount lifecycle methods\n\t\tif (!componentRoot) flushMounts();\n\t}\n\n\treturn ret;\n}\n\n/** Internals of `diff()`, separated to allow bypassing diffLevel / mount flushing. */\nfunction idiff(dom, vnode, context, mountAll, componentRoot) {\n\tvar out = dom,\n\t    prevSvgMode = isSvgMode;\n\n\t// empty values (null, undefined, booleans) render as empty Text nodes\n\tif (vnode == null || typeof vnode === 'boolean') vnode = '';\n\n\t// Fast case: Strings & Numbers create/update Text nodes.\n\tif (typeof vnode === 'string' || typeof vnode === 'number') {\n\n\t\t// update if it's already a Text node:\n\t\tif (dom && dom.splitText !== undefined && dom.parentNode && (!dom._component || componentRoot)) {\n\t\t\t/* istanbul ignore if */ /* Browser quirk that can't be covered: https://github.com/developit/preact/commit/fd4f21f5c45dfd75151bd27b4c217d8003aa5eb9 */\n\t\t\tif (dom.nodeValue != vnode) {\n\t\t\t\tdom.nodeValue = vnode;\n\t\t\t}\n\t\t} else {\n\t\t\t// it wasn't a Text node: replace it with one and recycle the old Element\n\t\t\tout = document.createTextNode(vnode);\n\t\t\tif (dom) {\n\t\t\t\tif (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n\t\t\t\trecollectNodeTree(dom, true);\n\t\t\t}\n\t\t}\n\n\t\tout['__preactattr_'] = true;\n\n\t\treturn out;\n\t}\n\n\t// If the VNode represents a Component, perform a component diff:\n\tvar vnodeName = vnode.nodeName;\n\tif (typeof vnodeName === 'function') {\n\t\treturn buildComponentFromVNode(dom, vnode, context, mountAll);\n\t}\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tisSvgMode = vnodeName === 'svg' ? true : vnodeName === 'foreignObject' ? false : isSvgMode;\n\n\t// If there's no existing element or it's the wrong type, create a new one:\n\tvnodeName = String(vnodeName);\n\tif (!dom || !isNamedNode(dom, vnodeName)) {\n\t\tout = createNode(vnodeName, isSvgMode);\n\n\t\tif (dom) {\n\t\t\t// move children into the replacement node\n\t\t\twhile (dom.firstChild) {\n\t\t\t\tout.appendChild(dom.firstChild);\n\t\t\t} // if the previous Element was mounted into the DOM, replace it inline\n\t\t\tif (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n\n\t\t\t// recycle the old element (skips non-Element node types)\n\t\t\trecollectNodeTree(dom, true);\n\t\t}\n\t}\n\n\tvar fc = out.firstChild,\n\t    props = out['__preactattr_'],\n\t    vchildren = vnode.children;\n\n\tif (props == null) {\n\t\tprops = out['__preactattr_'] = {};\n\t\tfor (var a = out.attributes, i = a.length; i--;) {\n\t\t\tprops[a[i].name] = a[i].value;\n\t\t}\n\t}\n\n\t// Optimization: fast-path for elements containing a single TextNode:\n\tif (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === 'string' && fc != null && fc.splitText !== undefined && fc.nextSibling == null) {\n\t\tif (fc.nodeValue != vchildren[0]) {\n\t\t\tfc.nodeValue = vchildren[0];\n\t\t}\n\t}\n\t// otherwise, if there are existing or new children, diff them:\n\telse if (vchildren && vchildren.length || fc != null) {\n\t\t\tinnerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML != null);\n\t\t}\n\n\t// Apply attributes/props from VNode to the DOM Element:\n\tdiffAttributes(out, vnode.attributes, props);\n\n\t// restore previous SVG mode: (in case we're exiting an SVG namespace)\n\tisSvgMode = prevSvgMode;\n\n\treturn out;\n}\n\n/** Apply child and attribute changes between a VNode and a DOM Node to the DOM.\n *\t@param {Element} dom\t\t\tElement whose children should be compared & mutated\n *\t@param {Array} vchildren\t\tArray of VNodes to compare to `dom.childNodes`\n *\t@param {Object} context\t\t\tImplicitly descendant context object (from most recent `getChildContext()`)\n *\t@param {Boolean} mountAll\n *\t@param {Boolean} isHydrating\tIf `true`, consumes externally created elements similar to hydration\n */\nfunction innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {\n\tvar originalChildren = dom.childNodes,\n\t    children = [],\n\t    keyed = {},\n\t    keyedLen = 0,\n\t    min = 0,\n\t    len = originalChildren.length,\n\t    childrenLen = 0,\n\t    vlen = vchildren ? vchildren.length : 0,\n\t    j,\n\t    c,\n\t    f,\n\t    vchild,\n\t    child;\n\n\t// Build up a map of keyed children and an Array of unkeyed children:\n\tif (len !== 0) {\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar _child = originalChildren[i],\n\t\t\t    props = _child['__preactattr_'],\n\t\t\t    key = vlen && props ? _child._component ? _child._component.__key : props.key : null;\n\t\t\tif (key != null) {\n\t\t\t\tkeyedLen++;\n\t\t\t\tkeyed[key] = _child;\n\t\t\t} else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {\n\t\t\t\tchildren[childrenLen++] = _child;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (vlen !== 0) {\n\t\tfor (var i = 0; i < vlen; i++) {\n\t\t\tvchild = vchildren[i];\n\t\t\tchild = null;\n\n\t\t\t// attempt to find a node based on key matching\n\t\t\tvar key = vchild.key;\n\t\t\tif (key != null) {\n\t\t\t\tif (keyedLen && keyed[key] !== undefined) {\n\t\t\t\t\tchild = keyed[key];\n\t\t\t\t\tkeyed[key] = undefined;\n\t\t\t\t\tkeyedLen--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// attempt to pluck a node of the same type from the existing children\n\t\t\telse if (!child && min < childrenLen) {\n\t\t\t\t\tfor (j = min; j < childrenLen; j++) {\n\t\t\t\t\t\tif (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {\n\t\t\t\t\t\t\tchild = c;\n\t\t\t\t\t\t\tchildren[j] = undefined;\n\t\t\t\t\t\t\tif (j === childrenLen - 1) childrenLen--;\n\t\t\t\t\t\t\tif (j === min) min++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// morph the matched/found/created DOM child to match vchild (deep)\n\t\t\tchild = idiff(child, vchild, context, mountAll);\n\n\t\t\tf = originalChildren[i];\n\t\t\tif (child && child !== dom && child !== f) {\n\t\t\t\tif (f == null) {\n\t\t\t\t\tdom.appendChild(child);\n\t\t\t\t} else if (child === f.nextSibling) {\n\t\t\t\t\tremoveNode(f);\n\t\t\t\t} else {\n\t\t\t\t\tdom.insertBefore(child, f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// remove unused keyed children:\n\tif (keyedLen) {\n\t\tfor (var i in keyed) {\n\t\t\tif (keyed[i] !== undefined) recollectNodeTree(keyed[i], false);\n\t\t}\n\t}\n\n\t// remove orphaned unkeyed children:\n\twhile (min <= childrenLen) {\n\t\tif ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);\n\t}\n}\n\n/** Recursively recycle (or just unmount) a node and its descendants.\n *\t@param {Node} node\t\t\t\t\t\tDOM node to start unmount/removal from\n *\t@param {Boolean} [unmountOnly=false]\tIf `true`, only triggers unmount lifecycle, skips removal\n */\nfunction recollectNodeTree(node, unmountOnly) {\n\tvar component = node._component;\n\tif (component) {\n\t\t// if node is owned by a Component, unmount that component (ends up recursing back here)\n\t\tunmountComponent(component);\n\t} else {\n\t\t// If the node's VNode had a ref function, invoke it with null here.\n\t\t// (this is part of the React spec, and smart for unsetting references)\n\t\tif (node['__preactattr_'] != null && node['__preactattr_'].ref) node['__preactattr_'].ref(null);\n\n\t\tif (unmountOnly === false || node['__preactattr_'] == null) {\n\t\t\tremoveNode(node);\n\t\t}\n\n\t\tremoveChildren(node);\n\t}\n}\n\n/** Recollect/unmount all children.\n *\t- we use .lastChild here because it causes less reflow than .firstChild\n *\t- it's also cheaper than accessing the .childNodes Live NodeList\n */\nfunction removeChildren(node) {\n\tnode = node.lastChild;\n\twhile (node) {\n\t\tvar next = node.previousSibling;\n\t\trecollectNodeTree(node, true);\n\t\tnode = next;\n\t}\n}\n\n/** Apply differences in attributes from a VNode to the given DOM Element.\n *\t@param {Element} dom\t\tElement with attributes to diff `attrs` against\n *\t@param {Object} attrs\t\tThe desired end-state key-value attribute pairs\n *\t@param {Object} old\t\t\tCurrent/previous attributes (from previous VNode or element's prop cache)\n */\nfunction diffAttributes(dom, attrs, old) {\n\tvar name;\n\n\t// remove attributes no longer present on the vnode by setting them to undefined\n\tfor (name in old) {\n\t\tif (!(attrs && attrs[name] != null) && old[name] != null) {\n\t\t\tsetAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);\n\t\t}\n\t}\n\n\t// add new & update changed attributes\n\tfor (name in attrs) {\n\t\tif (name !== 'children' && name !== 'innerHTML' && (!(name in old) || attrs[name] !== (name === 'value' || name === 'checked' ? dom[name] : old[name]))) {\n\t\t\tsetAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);\n\t\t}\n\t}\n}\n\n/** Retains a pool of Components for re-use, keyed on component name.\n *\tNote: since component names are not unique or even necessarily available, these are primarily a form of sharding.\n *\t@private\n */\nvar components = {};\n\n/** Reclaim a component for later re-use by the recycler. */\nfunction collectComponent(component) {\n\tvar name = component.constructor.name;\n\t(components[name] || (components[name] = [])).push(component);\n}\n\n/** Create a component. Normalizes differences between PFC's and classful Components. */\nfunction createComponent(Ctor, props, context) {\n\tvar list = components[Ctor.name],\n\t    inst;\n\n\tif (Ctor.prototype && Ctor.prototype.render) {\n\t\tinst = new Ctor(props, context);\n\t\tComponent.call(inst, props, context);\n\t} else {\n\t\tinst = new Component(props, context);\n\t\tinst.constructor = Ctor;\n\t\tinst.render = doRender;\n\t}\n\n\tif (list) {\n\t\tfor (var i = list.length; i--;) {\n\t\t\tif (list[i].constructor === Ctor) {\n\t\t\t\tinst.nextBase = list[i].nextBase;\n\t\t\t\tlist.splice(i, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn inst;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n\n/** Set a component's `props` (generally derived from JSX attributes).\n *\t@param {Object} props\n *\t@param {Object} [opts]\n *\t@param {boolean} [opts.renderSync=false]\tIf `true` and {@link options.syncComponentUpdates} is `true`, triggers synchronous rendering.\n *\t@param {boolean} [opts.render=true]\t\t\tIf `false`, no render will be triggered.\n */\nfunction setComponentProps(component, props, opts, context, mountAll) {\n\tif (component._disable) return;\n\tcomponent._disable = true;\n\n\tif (component.__ref = props.ref) delete props.ref;\n\tif (component.__key = props.key) delete props.key;\n\n\tif (!component.base || mountAll) {\n\t\tif (component.componentWillMount) component.componentWillMount();\n\t} else if (component.componentWillReceiveProps) {\n\t\tcomponent.componentWillReceiveProps(props, context);\n\t}\n\n\tif (context && context !== component.context) {\n\t\tif (!component.prevContext) component.prevContext = component.context;\n\t\tcomponent.context = context;\n\t}\n\n\tif (!component.prevProps) component.prevProps = component.props;\n\tcomponent.props = props;\n\n\tcomponent._disable = false;\n\n\tif (opts !== 0) {\n\t\tif (opts === 1 || options.syncComponentUpdates !== false || !component.base) {\n\t\t\trenderComponent(component, 1, mountAll);\n\t\t} else {\n\t\t\tenqueueRender(component);\n\t\t}\n\t}\n\n\tif (component.__ref) component.__ref(component);\n}\n\n/** Render a Component, triggering necessary lifecycle events and taking High-Order Components into account.\n *\t@param {Component} component\n *\t@param {Object} [opts]\n *\t@param {boolean} [opts.build=false]\t\tIf `true`, component will build and store a DOM node if not already associated with one.\n *\t@private\n */\nfunction renderComponent(component, opts, mountAll, isChild) {\n\tif (component._disable) return;\n\n\tvar props = component.props,\n\t    state = component.state,\n\t    context = component.context,\n\t    previousProps = component.prevProps || props,\n\t    previousState = component.prevState || state,\n\t    previousContext = component.prevContext || context,\n\t    isUpdate = component.base,\n\t    nextBase = component.nextBase,\n\t    initialBase = isUpdate || nextBase,\n\t    initialChildComponent = component._component,\n\t    skip = false,\n\t    rendered,\n\t    inst,\n\t    cbase;\n\n\t// if updating\n\tif (isUpdate) {\n\t\tcomponent.props = previousProps;\n\t\tcomponent.state = previousState;\n\t\tcomponent.context = previousContext;\n\t\tif (opts !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {\n\t\t\tskip = true;\n\t\t} else if (component.componentWillUpdate) {\n\t\t\tcomponent.componentWillUpdate(props, state, context);\n\t\t}\n\t\tcomponent.props = props;\n\t\tcomponent.state = state;\n\t\tcomponent.context = context;\n\t}\n\n\tcomponent.prevProps = component.prevState = component.prevContext = component.nextBase = null;\n\tcomponent._dirty = false;\n\n\tif (!skip) {\n\t\trendered = component.render(props, state, context);\n\n\t\t// context to pass to the child, can be updated via (grand-)parent component\n\t\tif (component.getChildContext) {\n\t\t\tcontext = extend(extend({}, context), component.getChildContext());\n\t\t}\n\n\t\tvar childComponent = rendered && rendered.nodeName,\n\t\t    toUnmount,\n\t\t    base;\n\n\t\tif (typeof childComponent === 'function') {\n\t\t\t// set up high order component link\n\n\t\t\tvar childProps = getNodeProps(rendered);\n\t\t\tinst = initialChildComponent;\n\n\t\t\tif (inst && inst.constructor === childComponent && childProps.key == inst.__key) {\n\t\t\t\tsetComponentProps(inst, childProps, 1, context, false);\n\t\t\t} else {\n\t\t\t\ttoUnmount = inst;\n\n\t\t\t\tcomponent._component = inst = createComponent(childComponent, childProps, context);\n\t\t\t\tinst.nextBase = inst.nextBase || nextBase;\n\t\t\t\tinst._parentComponent = component;\n\t\t\t\tsetComponentProps(inst, childProps, 0, context, false);\n\t\t\t\trenderComponent(inst, 1, mountAll, true);\n\t\t\t}\n\n\t\t\tbase = inst.base;\n\t\t} else {\n\t\t\tcbase = initialBase;\n\n\t\t\t// destroy high order component link\n\t\t\ttoUnmount = initialChildComponent;\n\t\t\tif (toUnmount) {\n\t\t\t\tcbase = component._component = null;\n\t\t\t}\n\n\t\t\tif (initialBase || opts === 1) {\n\t\t\t\tif (cbase) cbase._component = null;\n\t\t\t\tbase = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);\n\t\t\t}\n\t\t}\n\n\t\tif (initialBase && base !== initialBase && inst !== initialChildComponent) {\n\t\t\tvar baseParent = initialBase.parentNode;\n\t\t\tif (baseParent && base !== baseParent) {\n\t\t\t\tbaseParent.replaceChild(base, initialBase);\n\n\t\t\t\tif (!toUnmount) {\n\t\t\t\t\tinitialBase._component = null;\n\t\t\t\t\trecollectNodeTree(initialBase, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (toUnmount) {\n\t\t\tunmountComponent(toUnmount);\n\t\t}\n\n\t\tcomponent.base = base;\n\t\tif (base && !isChild) {\n\t\t\tvar componentRef = component,\n\t\t\t    t = component;\n\t\t\twhile (t = t._parentComponent) {\n\t\t\t\t(componentRef = t).base = base;\n\t\t\t}\n\t\t\tbase._component = componentRef;\n\t\t\tbase._componentConstructor = componentRef.constructor;\n\t\t}\n\t}\n\n\tif (!isUpdate || mountAll) {\n\t\tmounts.unshift(component);\n\t} else if (!skip) {\n\t\t// Ensure that pending componentDidMount() hooks of child components\n\t\t// are called before the componentDidUpdate() hook in the parent.\n\t\t// Note: disabled as it causes duplicate hooks, see https://github.com/developit/preact/issues/750\n\t\t// flushMounts();\n\n\t\tif (component.componentDidUpdate) {\n\t\t\tcomponent.componentDidUpdate(previousProps, previousState, previousContext);\n\t\t}\n\t\tif (options.afterUpdate) options.afterUpdate(component);\n\t}\n\n\tif (component._renderCallbacks != null) {\n\t\twhile (component._renderCallbacks.length) {\n\t\t\tcomponent._renderCallbacks.pop().call(component);\n\t\t}\n\t}\n\n\tif (!diffLevel && !isChild) flushMounts();\n}\n\n/** Apply the Component referenced by a VNode to the DOM.\n *\t@param {Element} dom\tThe DOM node to mutate\n *\t@param {VNode} vnode\tA Component-referencing VNode\n *\t@returns {Element} dom\tThe created/mutated element\n *\t@private\n */\nfunction buildComponentFromVNode(dom, vnode, context, mountAll) {\n\tvar c = dom && dom._component,\n\t    originalComponent = c,\n\t    oldDom = dom,\n\t    isDirectOwner = c && dom._componentConstructor === vnode.nodeName,\n\t    isOwner = isDirectOwner,\n\t    props = getNodeProps(vnode);\n\twhile (c && !isOwner && (c = c._parentComponent)) {\n\t\tisOwner = c.constructor === vnode.nodeName;\n\t}\n\n\tif (c && isOwner && (!mountAll || c._component)) {\n\t\tsetComponentProps(c, props, 3, context, mountAll);\n\t\tdom = c.base;\n\t} else {\n\t\tif (originalComponent && !isDirectOwner) {\n\t\t\tunmountComponent(originalComponent);\n\t\t\tdom = oldDom = null;\n\t\t}\n\n\t\tc = createComponent(vnode.nodeName, props, context);\n\t\tif (dom && !c.nextBase) {\n\t\t\tc.nextBase = dom;\n\t\t\t// passing dom/oldDom as nextBase will recycle it if unused, so bypass recycling on L229:\n\t\t\toldDom = null;\n\t\t}\n\t\tsetComponentProps(c, props, 1, context, mountAll);\n\t\tdom = c.base;\n\n\t\tif (oldDom && dom !== oldDom) {\n\t\t\toldDom._component = null;\n\t\t\trecollectNodeTree(oldDom, false);\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/** Remove a component from the DOM and recycle it.\n *\t@param {Component} component\tThe Component instance to unmount\n *\t@private\n */\nfunction unmountComponent(component) {\n\tif (options.beforeUnmount) options.beforeUnmount(component);\n\n\tvar base = component.base;\n\n\tcomponent._disable = true;\n\n\tif (component.componentWillUnmount) component.componentWillUnmount();\n\n\tcomponent.base = null;\n\n\t// recursively tear down & recollect high-order component children:\n\tvar inner = component._component;\n\tif (inner) {\n\t\tunmountComponent(inner);\n\t} else if (base) {\n\t\tif (base['__preactattr_'] && base['__preactattr_'].ref) base['__preactattr_'].ref(null);\n\n\t\tcomponent.nextBase = base;\n\n\t\tremoveNode(base);\n\t\tcollectComponent(component);\n\n\t\tremoveChildren(base);\n\t}\n\n\tif (component.__ref) component.__ref(null);\n}\n\n/** Base Component class.\n *\tProvides `setState()` and `forceUpdate()`, which trigger rendering.\n *\t@public\n *\n *\t@example\n *\tclass MyFoo extends Component {\n *\t\trender(props, state) {\n *\t\t\treturn <div />;\n *\t\t}\n *\t}\n */\nfunction Component(props, context) {\n\tthis._dirty = true;\n\n\t/** @public\n  *\t@type {object}\n  */\n\tthis.context = context;\n\n\t/** @public\n  *\t@type {object}\n  */\n\tthis.props = props;\n\n\t/** @public\n  *\t@type {object}\n  */\n\tthis.state = this.state || {};\n}\n\nextend(Component.prototype, {\n\n\t/** Returns a `boolean` indicating if the component should re-render when receiving the given `props` and `state`.\n  *\t@param {object} nextProps\n  *\t@param {object} nextState\n  *\t@param {object} nextContext\n  *\t@returns {Boolean} should the component re-render\n  *\t@name shouldComponentUpdate\n  *\t@function\n  */\n\n\t/** Update component state by copying properties from `state` to `this.state`.\n  *\t@param {object} state\t\tA hash of state properties to update with new values\n  *\t@param {function} callback\tA function to be called once component state is updated\n  */\n\tsetState: function setState(state, callback) {\n\t\tvar s = this.state;\n\t\tif (!this.prevState) this.prevState = extend({}, s);\n\t\textend(s, typeof state === 'function' ? state(s, this.props) : state);\n\t\tif (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);\n\t\tenqueueRender(this);\n\t},\n\n\n\t/** Immediately perform a synchronous re-render of the component.\n  *\t@param {function} callback\t\tA function to be called after component is re-rendered.\n  *\t@private\n  */\n\tforceUpdate: function forceUpdate(callback) {\n\t\tif (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);\n\t\trenderComponent(this, 2);\n\t},\n\n\n\t/** Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n  *\tVirtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n  *\t@param {object} props\t\tProps (eg: JSX attributes) received from parent element/component\n  *\t@param {object} state\t\tThe component's current state\n  *\t@param {object} context\t\tContext object (if a parent component has provided context)\n  *\t@returns VNode\n  */\n\trender: function render() {}\n});\n\n/** Render JSX into a `parent` Element.\n *\t@param {VNode} vnode\t\tA (JSX) VNode to render\n *\t@param {Element} parent\t\tDOM element to render into\n *\t@param {Element} [merge]\tAttempt to re-use an existing DOM tree rooted at `merge`\n *\t@public\n *\n *\t@example\n *\t// render a div into <body>:\n *\trender(<div id=\"hello\">hello!</div>, document.body);\n *\n *\t@example\n *\t// render a \"Thing\" component into #foo:\n *\tconst Thing = ({ name }) => <span>{ name }</span>;\n *\trender(<Thing name=\"one\" />, document.querySelector('#foo'));\n */\nfunction render(vnode, parent, merge) {\n  return diff(merge, vnode, {}, false, parent, false);\n}\n\nvar preact = {\n\th: h,\n\tcreateElement: h,\n\tcloneElement: cloneElement,\n\tComponent: Component,\n\trender: render,\n\trerender: rerender,\n\toptions: options\n};\n\nexport { h, h as createElement, cloneElement, Component, render, rerender, options };export default preact;\n//# sourceMappingURL=preact.esm.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/preact/dist/preact.esm.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}